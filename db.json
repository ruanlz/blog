{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/indigo/source/css/style.less","path":"css/style.less","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/alipay.jpg","path":"img/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/brand.jpg","path":"img/brand.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/cc.png","path":"img/cc.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/img-err.png","path":"img/img-err.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/img-loading.png","path":"img/img-loading.png","modified":0,"renderable":1},{"_id":"themes/indigo/source/img/wechat.jpg","path":"img/wechat.jpg","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/main.min.js","path":"js/main.min.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/js/search.min.js","path":"js/search.min.js","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","path":"css/fonts/roboto/Roboto-Bold.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","path":"css/fonts/roboto/Roboto-Bold.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","path":"css/fonts/roboto/Roboto-Bold.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","path":"css/fonts/roboto/Roboto-Light.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","path":"css/fonts/roboto/Roboto-Light.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","path":"css/fonts/roboto/Roboto-Light.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","path":"css/fonts/roboto/Roboto-Medium.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","path":"css/fonts/roboto/Roboto-Medium.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","path":"css/fonts/roboto/Roboto-Medium.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","path":"css/fonts/roboto/Roboto-Regular.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","path":"css/fonts/roboto/Roboto-Regular.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","path":"css/fonts/roboto/Roboto-Regular.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","path":"css/fonts/roboto/Roboto-Thin.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","path":"css/fonts/roboto/Roboto-Thin.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","path":"css/fonts/roboto/Roboto-Thin.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","path":"css/fonts/fontawesome/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","path":"css/fonts/fontawesome/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","path":"css/fonts/roboto/Roboto-Bold.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","path":"css/fonts/roboto/Roboto-Light.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","path":"css/fonts/roboto/Roboto-Medium.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","path":"css/fonts/roboto/Roboto-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","path":"css/fonts/roboto/Roboto-Thin.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","path":"css/fonts/fontawesome/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","path":"css/fonts/fontawesome/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","path":"css/fonts/fontawesome/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","path":"css/fonts/fontawesome/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/indigo/.editorconfig","hash":"67a03b88eadd7810f2e01866e73814074ecd3b87","modified":1524752212432},{"_id":"themes/indigo/_config.yml","hash":"65b69e34348f2df63eebf984227a4ccd7d754cf0","modified":1524752212448},{"_id":"themes/indigo/package.json","hash":"41a9b54da941028d094874d9f3b4ec1055ce8b82","modified":1524983455599},{"_id":"themes/indigo/README.md","hash":"480f6efbd0fcf50308b22bc3af7a8c79e56601f8","modified":1523890803917},{"_id":"themes/indigo/LICENSE","hash":"9dd0f70bc72c9d575447655526aded395bb93754","modified":1523890803916},{"_id":"themes/indigo/languages/ja.yml","hash":"65a32717335211a45771a21fb7d7778808c6f0aa","modified":1523890803921},{"_id":"themes/indigo/languages/en.yml","hash":"ba78def0453d08172248e220a1f9e145e99b4f23","modified":1523890803920},{"_id":"themes/indigo/languages/nl-NL","hash":"b540b76af76c1a180c517089ed2ad770cbded170","modified":1523890803922},{"_id":"themes/indigo/languages/zh-CN.yml","hash":"6806e4c305facf19cbe4e37ccc5d6b00cb56e199","modified":1523890803922},{"_id":"themes/indigo/languages/zh-TW.yml","hash":"9b8bdd9c8b68716f364503926dca6ba8571ee5ff","modified":1523890803923},{"_id":"themes/indigo/layout/archive.ejs","hash":"6897178ba358379d6a4b7c0ba1bc2ab97ad5303a","modified":1523890803963},{"_id":"themes/indigo/layout/categories.ejs","hash":"efae06b4d83aaf73ab93260381e891825bf404ac","modified":1523890803964},{"_id":"themes/indigo/layout/category.ejs","hash":"e5ba5cc2e092c199285b8097ef12ffe70bf84c91","modified":1523890803965},{"_id":"themes/indigo/layout/index.ejs","hash":"772c1985c7743e101598b4eddc253f9174c5605b","modified":1523890803966},{"_id":"themes/indigo/layout/layout.ejs","hash":"770af84fff104c398ce8b6c995130cddd3e9a1e9","modified":1523890803967},{"_id":"themes/indigo/layout/page.ejs","hash":"567c42b978da4c39b8b4982df19b940c26bc32a4","modified":1523890803967},{"_id":"themes/indigo/layout/post.ejs","hash":"efc3352828351f8574c51e8a93dc56c66660c3b1","modified":1523890803968},{"_id":"themes/indigo/layout/tag.ejs","hash":"90a231dea3a364b329a740e5d6c49c8cf5664fe9","modified":1523890803969},{"_id":"themes/indigo/layout/tags.ejs","hash":"1fc0461e9602b53899ec756e4361beb8cce74740","modified":1523890803970},{"_id":"themes/indigo/scripts/plugins.js","hash":"00ea278ea77733f546439aed507ce69a298da362","modified":1523890803973},{"_id":"source/_posts/Markdown语法入门.md","hash":"8c8653c5bbc1cef61af739961c3b4cb7361ab906","modified":1524984166994},{"_id":"source/_posts/Nihao-blog.md","hash":"d84e9e6fa5d07213ea902a05c6bccb16bdb43739","modified":1524984167004},{"_id":"source/_posts/new.md","hash":"4e851bd198a2602453fa9846379e64eccd088aa8","modified":1524984167027},{"_id":"source/_posts/使用Github和Hexo搭建博客.md","hash":"9455eac36ae5048bcd141c9bba1b021fb7b5e4ae","modified":1524984167032},{"_id":"source/_posts/冒泡排序.md","hash":"a473bd34c191314223732ff863a98e556f3955e3","modified":1524984167039},{"_id":"source/_posts/基数排序.md","hash":"f463da32369fe54424475f7312108de2df4beecb","modified":1524984167046},{"_id":"source/_posts/堆排序.md","hash":"294a9941e74b1713553b3f0738a976ac32362cda","modified":1524984167055},{"_id":"source/_posts/归并排序.md","hash":"bb9b7031fb326410f0a85c085c63d05c821fc7b2","modified":1524984167063},{"_id":"source/_posts/快速排序.md","hash":"33e03df91e7fe89821841db9de8060d96a4b5bdd","modified":1524984167072},{"_id":"source/_posts/插入排序.md","hash":"2f7d3bc08296cdf76890a3dd20099647f4324680","modified":1524984167077},{"_id":"source/_posts/桶排序.md","hash":"1f6380eb4e92c54c2a2c4bf5e6573dc24f1feb86","modified":1524984167084},{"_id":"source/_posts/虚拟机安装CentOS教程.md","hash":"e25786793edd598ffa77dee548695468a958d396","modified":1524984167090},{"_id":"source/_posts/虽yi.md","hash":"e0dd9fe042d08cba105c89b6fcb940f9b0582611","modified":1524984167103},{"_id":"source/_posts/计数排序.md","hash":"647f33aaaa69a5d0e6e4cfee3868467474b3967d","modified":1524984167109},{"_id":"source/_posts/选择排序.md","hash":"fe6c2980d25e9582c976e644ff1378fd34a638b3","modified":1524984167116},{"_id":"themes/indigo/layout/_partial/after-footer.ejs","hash":"1351dbfca311f0d50a939f9e1a91c4f65bbcdf5f","modified":1523890803925},{"_id":"themes/indigo/layout/_partial/archive.ejs","hash":"c294c98617ce14082f9b3d5eec83328f480f5597","modified":1523890803926},{"_id":"themes/indigo/layout/_partial/footer.ejs","hash":"c78444f5b350ca79b260361bf3e5b6361d2661ba","modified":1523890803927},{"_id":"themes/indigo/layout/_partial/head.ejs","hash":"9dfc591ec6c918c5b60b6ccbc5d1e18fea9faf8e","modified":1523890803928},{"_id":"themes/indigo/layout/_partial/header.ejs","hash":"648db446567a81371b8a29d719d13636aa157012","modified":1523890803928},{"_id":"themes/indigo/layout/_partial/index-item.ejs","hash":"7208d4083ee3355aa969972a2ce249a67d56b3a6","modified":1523890803929},{"_id":"themes/indigo/layout/_partial/loading.ejs","hash":"8b3e037dd5f3d4564012689c5cd6f63caf73df0f","modified":1523890803930},{"_id":"themes/indigo/layout/_partial/menu.ejs","hash":"ea6aded24a68de0914f24b3760f766b5e1c9835a","modified":1523890803931},{"_id":"themes/indigo/layout/_partial/paginator.ejs","hash":"13952250463f70d1c1bbbfdd7f4ee8160dd6d99b","modified":1523890803932},{"_id":"themes/indigo/layout/_partial/post.ejs","hash":"20597ac0d547aea37680ecf195eb129fe5ee19d8","modified":1523890803945},{"_id":"themes/indigo/layout/_partial/script.ejs","hash":"31052bc524a10abd6871aed2415448ce585faff2","modified":1523890803960},{"_id":"themes/indigo/layout/_partial/search.ejs","hash":"752109904304fdb8e988ee1254df2af9c0701466","modified":1523890803961},{"_id":"themes/indigo/layout/_partial/tags-bar.ejs","hash":"30ec74f081cc4c273a7bcd5d57da99072e9f0755","modified":1523890803962},{"_id":"themes/indigo/source/css/style.less","hash":"cf362925ae099b810fd5763e6b724b823612ed15","modified":1523890804041},{"_id":"themes/indigo/source/img/alipay.jpg","hash":"6054d9ed2ca7cd1f645b729e05632134467d4daa","modified":1523890804043},{"_id":"themes/indigo/source/img/avatar.jpg","hash":"62a4893b1a32e997dcdb6e467b10559df75221e2","modified":1523890804044},{"_id":"themes/indigo/source/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1523890804045},{"_id":"themes/indigo/source/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1523890804046},{"_id":"themes/indigo/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1523890804047},{"_id":"themes/indigo/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1523890804048},{"_id":"themes/indigo/source/img/wechat.jpg","hash":"ef069cc9e80c7553fd60589b0727bbbf8c6de372","modified":1523890804049},{"_id":"themes/indigo/source/js/main.js","hash":"ff44bb7b2f1f08757093fd6ffa92c9ac2b674109","modified":1523890804051},{"_id":"themes/indigo/source/js/main.min.js","hash":"e77a89fe5a9827ac590a288778176b233dd900ad","modified":1523890804052},{"_id":"themes/indigo/source/js/search.js","hash":"a4d6c9c566ec1ca71ddacfd14c58f7ddaf9db24d","modified":1523890804053},{"_id":"themes/indigo/source/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1523890804054},{"_id":"source/_posts/Markdown语法入门/biaoti1.jpg","hash":"0be5f8e389c7da2e4674b7e324c3f0fd328bad13","modified":1524984167001},{"_id":"source/_posts/虚拟机安装CentOS教程/1.jpg","hash":"982125edaf8d470d06e5a90d64d396a979927468","modified":1524984167097},{"_id":"themes/indigo/layout/_partial/plugins/baidu.ejs","hash":"da1355eea131952031e54c45560555e6d3aa5a33","modified":1523890803933},{"_id":"themes/indigo/layout/_partial/plugins/disqus.ejs","hash":"86fe837ab16cb60754b0a73bb9efa38b04f3023f","modified":1523890803934},{"_id":"themes/indigo/layout/_partial/plugins/dynamic-title.ejs","hash":"3b877868c4a6fc217ea6f3314544830280a77472","modified":1523890803935},{"_id":"themes/indigo/layout/_partial/plugins/gitment.ejs","hash":"5f6ceb7f4b9b579e8e3f87894447f556a53f9385","modified":1523890803936},{"_id":"themes/indigo/layout/_partial/plugins/google-analytics.ejs","hash":"b5b87761751a897949e085a8f1ace78b0b8babd5","modified":1523890803937},{"_id":"themes/indigo/layout/_partial/plugins/hyper-comments.ejs","hash":"d0e6f1d713e7a1c0cc5fe25f3e574a4b791f938a","modified":1523890803938},{"_id":"themes/indigo/layout/_partial/plugins/mathjax.ejs","hash":"3a5c9f7d22d30cd8ffa4e83a8d3976db22815994","modified":1523890803939},{"_id":"themes/indigo/layout/_partial/plugins/page-visit.ejs","hash":"bb9deb32c54ea6820f622b923e62592915e9f21f","modified":1523890803940},{"_id":"themes/indigo/layout/_partial/plugins/site-visit.ejs","hash":"a2c247c2e32016563dd6a22c21474072d93f4dbd","modified":1523890803941},{"_id":"themes/indigo/layout/_partial/plugins/tajs.ejs","hash":"ef9c77d8c6e004b014c83c5f9333e7174f8bafa3","modified":1523890803942},{"_id":"themes/indigo/layout/_partial/plugins/uyan.ejs","hash":"ddf290e90dc1c779f42a48e1bd852ca932148dfb","modified":1523890803943},{"_id":"themes/indigo/layout/_partial/plugins/valine.ejs","hash":"0a6245da90d54177441d32a6f1766b4f434660db","modified":1523890803944},{"_id":"themes/indigo/layout/_partial/post/category.ejs","hash":"c08e44cbd7315dec7afb6054b04d3c7b82c3bde8","modified":1523890803947},{"_id":"themes/indigo/layout/_partial/post/comment.ejs","hash":"b1a6984e19d3493fb327383ee76e09fdee090426","modified":1523890803948},{"_id":"themes/indigo/layout/_partial/post/copyright.ejs","hash":"dd1dcc7776021ab3d68065f8532efead4c2b8051","modified":1523890803949},{"_id":"themes/indigo/layout/_partial/post/date.ejs","hash":"c5adcec8db1506c378d39855a697e1bb1165646c","modified":1523890803950},{"_id":"themes/indigo/layout/_partial/post/head-meta.ejs","hash":"f137c126672769e9571be2bb0a70ea8dda644b0e","modified":1523890803951},{"_id":"themes/indigo/layout/_partial/post/nav.ejs","hash":"03719097851575a2c1bb95774058b224f6402a1f","modified":1523890803952},{"_id":"themes/indigo/layout/_partial/post/reward-btn.ejs","hash":"b46160005224821a439dec9f1ff183e2f66d9f4b","modified":1523890803953},{"_id":"themes/indigo/layout/_partial/post/reward.ejs","hash":"097c0276a61665e5ee96e5d5d85a7d6ae5ab2f49","modified":1523890803954},{"_id":"themes/indigo/layout/_partial/post/share-fab.ejs","hash":"2ec7de870988cfbc8ea9872cddf7e4076ac64a57","modified":1523890803955},{"_id":"themes/indigo/layout/_partial/post/share.ejs","hash":"7d79a67b3e5e6989f22fb0e0904fa540bfca5fcc","modified":1523890803956},{"_id":"themes/indigo/layout/_partial/post/tag.ejs","hash":"412894001b1ac6e63012b26b1109a0856651c076","modified":1523890803957},{"_id":"themes/indigo/layout/_partial/post/title.ejs","hash":"eaad7af7888bddd7095243a43ff38f55ad8c494a","modified":1523890803958},{"_id":"themes/indigo/layout/_partial/post/toc.ejs","hash":"d534b888d24df7703c632539d4bdd638fa764e98","modified":1523890803959},{"_id":"themes/indigo/layout/_partial/post/updated.ejs","hash":"00fedf7971c0bda0623d968bc0614e512d19a985","modified":1523890803960},{"_id":"themes/indigo/source/css/_partial/archives.less","hash":"382fc22cd5cc073e881768a65600d97eba9f1d21","modified":1523890803975},{"_id":"themes/indigo/source/css/_partial/article.less","hash":"f047c8ca92f9e6a8e1299ace0cce91514631a21c","modified":1523890803976},{"_id":"themes/indigo/source/css/_partial/gotop.less","hash":"bad63006b3bd4849bf53ad38482af0d9971061d3","modified":1523890803978},{"_id":"themes/indigo/source/css/_partial/header.less","hash":"880b4a28e97d556ed15b07642d25115f9b6ba4f6","modified":1523890803979},{"_id":"themes/indigo/source/css/_partial/highlight.less","hash":"99e48793dc0b4ffb66ecaf2d1315145872f9bb98","modified":1523890803980},{"_id":"themes/indigo/source/css/_partial/layout.less","hash":"5f783f34bf093e654e8922ed4a2af8b7b2cd41c4","modified":1523890803981},{"_id":"themes/indigo/source/css/_partial/lightbox.less","hash":"38419aaf3c1832e84ade331f051f110fdc8b960f","modified":1523890803982},{"_id":"themes/indigo/source/css/_partial/loading.less","hash":"85157ddf3877b5c58e8f1d737dda3dfb1bfd540b","modified":1523890803983},{"_id":"themes/indigo/source/css/_partial/page.less","hash":"33b0a5edcedc26a4c592c812c5785bb20d3c93db","modified":1523890803984},{"_id":"themes/indigo/source/css/_partial/postlist.less","hash":"516cded3c7f1db4cacfa898bcaf0adfae7f3a2e1","modified":1523890803985},{"_id":"themes/indigo/source/css/_partial/reward.less","hash":"f5e89ea5414e3096a28c8c96e86c3f669040a892","modified":1523890803986},{"_id":"themes/indigo/source/css/_partial/roboto.less","hash":"3e457942995da8840e7662fa6cb551a7e12ea294","modified":1523890803987},{"_id":"themes/indigo/source/css/_partial/search.less","hash":"dbc23e77e586ee682a21475f5eb568628ea6720f","modified":1523890803988},{"_id":"themes/indigo/source/css/_partial/share.less","hash":"a683c96a59470efd35722b763c55149a46e35156","modified":1523890803989},{"_id":"themes/indigo/source/css/_partial/tags.less","hash":"01eb7f84193180928a6ed4796ee8802f6c1628e7","modified":1523890803990},{"_id":"themes/indigo/source/css/_partial/variable.less","hash":"3232e75f4653402c9fbd7bda5b97c05ecc31db2b","modified":1523890803991},{"_id":"themes/indigo/source/css/_partial/waves.less","hash":"a02eaa601887f947257f6016679b62dc96a61c0c","modified":1523890803991},{"_id":"themes/indigo/source/css/_plugin/valine.less","hash":"b8f8d8037fb3c8525da12e580bd9e2ff9f298132","modified":1523890803993},{"_id":"themes/indigo/source/css/_partial/fontawesome.less","hash":"a3ecbd6ccf5b56ac39df710c34a149b82989a498","modified":1523890803978},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1523890804012},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1523890804015},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1523890804016},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1523890804017},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1523890804021},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1523890804022},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1523890804023},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1523890804027},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1523890804028},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1523890804029},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1523890804033},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1523890804034},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1523890804035},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1523890804039},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1523890804040},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1523890804009},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1523890804010},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1523890804014},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1523890804020},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1523890804025},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1523890804031},{"_id":"themes/indigo/source/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1523890804038},{"_id":"themes/indigo/source/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1523890803996},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1523890803999},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1523890804007},{"_id":"themes/indigo/source/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1523890804004},{"_id":"public/atom.xml","hash":"3603f67d76d89be5448a71d2818e5712d480896b","modified":1524988230301},{"_id":"public/content.json","hash":"692e7ba28fd3b0628b95e8c4c49dae5b2b6d05ee","modified":1524988230878},{"_id":"public/2018/04/21/Nihao-blog/index.html","hash":"cab6bc54af006e3bc7fe9fe076036d2aec0d1709","modified":1524988230889},{"_id":"public/categories/技术分享/index.html","hash":"2ce99c24c40d367711ba2f3122d10082b8d5d1c2","modified":1524988230889},{"_id":"public/categories/技术分享/工具安装/index.html","hash":"e3c79875a41a80ce6a49113d1a40f94b039b6cfb","modified":1524988230890},{"_id":"public/tags/工具安装/index.html","hash":"bc36b9a3cb1f970912454be73082d57838f1156b","modified":1524988230890},{"_id":"public/tags/操作系统/index.html","hash":"b9021d94ecd448c11a985ba8ab866180044266cb","modified":1524988230890},{"_id":"public/2018/04/29/使用Github和Hexo搭建博客/index.html","hash":"28c7f81612b0732afb2df5066b6b75f57893e5ed","modified":1524988230890},{"_id":"public/2018/04/16/归并排序/index.html","hash":"5891be4c1e4c2e23683bbe20af1e05429e6d0f68","modified":1524988230890},{"_id":"public/2018/04/16/选择排序/index.html","hash":"8cf917bdc91c9c4c1c9eafb3551a673abaf427f8","modified":1524988230890},{"_id":"public/2018/04/16/冒泡排序/index.html","hash":"8d80b0f7403fd041e195bdd8e2076ca4a396513c","modified":1524988230890},{"_id":"public/2018/04/16/基数排序/index.html","hash":"91384adea761879fa6ce111aeb078818148f2112","modified":1524988230890},{"_id":"public/2018/04/16/堆排序/index.html","hash":"3d29103bd5328efd6356c825faa3b4a9f17c1aa2","modified":1524988230890},{"_id":"public/2018/04/16/new/index.html","hash":"a3aba811cd5c23c0ad29e48f6ed44ec842313198","modified":1524988230890},{"_id":"public/2018/04/16/快速排序/index.html","hash":"01427d9ea86ddd29ccbbcf41d8df833e99eb4510","modified":1524988230891},{"_id":"public/2018/04/16/插入排序/index.html","hash":"4c059cd04637deceb5aa5697f71ff7f91380dd9f","modified":1524988230891},{"_id":"public/2018/04/16/桶排序/index.html","hash":"0f6e97becb5731c98a1eb216046c23779071317e","modified":1524988230891},{"_id":"public/2018/04/16/虽yi/index.html","hash":"3aefd8af0e11411dd6ab017ce4fac2b229383e99","modified":1524988230891},{"_id":"public/2018/04/16/虚拟机安装CentOS教程/index.html","hash":"6296e974ce97993a24754745e84e649352108cba","modified":1524988230891},{"_id":"public/2018/04/16/计数排序/index.html","hash":"af6c704865ace42b22eec8a19cb2bc5ac0413475","modified":1524988230891},{"_id":"public/2018/04/15/Markdown语法入门/index.html","hash":"539bd62354ede3c5287ca707f5368b5253f0edab","modified":1524988230891},{"_id":"public/categories/基础知识/index.html","hash":"ed4509f35d484aade77a336ea806f6cd9a7141b4","modified":1524988230891},{"_id":"public/categories/基础知识/算法排序/index.html","hash":"c34d08b7934121de5bde2287534f989b91e6c09d","modified":1524988230891},{"_id":"public/archives/index.html","hash":"0bf1e07a2889afd7719df62e8fff713a0478b182","modified":1524988230891},{"_id":"public/archives/2018/index.html","hash":"2c6c7b64e55a466013761d30eb9c13037bd319b3","modified":1524988230891},{"_id":"public/archives/2018/04/index.html","hash":"45e83c58d38de69825c2f84481aa5dfb77512930","modified":1524988230891},{"_id":"public/index.html","hash":"dd069ea7ceaefe07f08a5d23ae6a819c774ff925","modified":1524988230891},{"_id":"public/tags/算法排序/index.html","hash":"1f47568e693807bbff6f498db88a63cf7be801c8","modified":1524988230891},{"_id":"public/tags/基础知识/index.html","hash":"c2dcd824dc535dbdfd1ca88435ea41ec40eea763","modified":1524988230892},{"_id":"public/img/alipay.jpg","hash":"6054d9ed2ca7cd1f645b729e05632134467d4daa","modified":1524988230924},{"_id":"public/img/avatar.jpg","hash":"62a4893b1a32e997dcdb6e467b10559df75221e2","modified":1524988230924},{"_id":"public/img/brand.jpg","hash":"0e237f1b433851c156e1f1cdaeb044054b3b9879","modified":1524988230924},{"_id":"public/img/cc.png","hash":"ebce75a62b40976a72d43f0bd937d859ac24d87c","modified":1524988230925},{"_id":"public/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1524988230925},{"_id":"public/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1524988230925},{"_id":"public/img/wechat.jpg","hash":"ef069cc9e80c7553fd60589b0727bbbf8c6de372","modified":1524988230925},{"_id":"public/css/fonts/roboto/Roboto-Bold.eot","hash":"a76cd602f5188b9fbd4ba7443dcb9c064e3dbf10","modified":1524988230925},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff","hash":"ee99cd87a59a9a5d4092c83232bb3eec67547425","modified":1524988230925},{"_id":"public/css/fonts/roboto/Roboto-Bold.woff2","hash":"933b866d09c2b087707a98dab64b3888865eeb96","modified":1524988230925},{"_id":"public/css/fonts/roboto/Roboto-Light.eot","hash":"42fe156996197e5eb0c0264c5d1bb3b4681f4595","modified":1524988230925},{"_id":"public/css/fonts/roboto/Roboto-Light.woff","hash":"6300f659be9e834ab263efe2fb3c581d48b1e7b2","modified":1524988230925},{"_id":"public/css/fonts/roboto/Roboto-Light.woff2","hash":"bbdc28b887400fcb340b504ec2904993af42a5d7","modified":1524988230925},{"_id":"public/css/fonts/roboto/Roboto-Medium.eot","hash":"1517f4b6e1c5d0e5198f937557253aac8fab0416","modified":1524988230926},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff","hash":"d45f84922131364989ad6578c7a06b6b4fc22c34","modified":1524988230926},{"_id":"public/css/fonts/roboto/Roboto-Medium.woff2","hash":"6cc1b73571af9e827c4e7e91418f476703cd4c4b","modified":1524988230926},{"_id":"public/css/fonts/roboto/Roboto-Regular.eot","hash":"77ae3e980ec03863ebe2587a8ef9ddfd06941db0","modified":1524988230926},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff","hash":"74734dde8d94e7268170f9b994dedfbdcb5b3a15","modified":1524988230927},{"_id":"public/css/fonts/roboto/Roboto-Regular.woff2","hash":"ed1558b0541f5e01ce48c7db1588371b990eec19","modified":1524988230927},{"_id":"public/css/fonts/roboto/Roboto-Thin.eot","hash":"0790a51a848dbe7292c98f9d0459218bf1a8ffdd","modified":1524988230927},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff","hash":"fbc3e71d456c96667d8082ab910e3946ef89240b","modified":1524988230927},{"_id":"public/css/fonts/roboto/Roboto-Thin.woff2","hash":"2449e3dac5ddb7c3da8bb07450493b62d052758c","modified":1524988230927},{"_id":"public/2018/04/15/Markdown语法入门/biaoti1.jpg","hash":"0be5f8e389c7da2e4674b7e324c3f0fd328bad13","modified":1524988230927},{"_id":"public/2018/04/16/虚拟机安装CentOS教程/1.jpg","hash":"982125edaf8d470d06e5a90d64d396a979927468","modified":1524988230927},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1524988230969},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1524988230969},{"_id":"public/css/fonts/roboto/Roboto-Bold.ttf","hash":"47327df0f35e7cd7c8645874897a7449697544ae","modified":1524988230969},{"_id":"public/css/fonts/roboto/Roboto-Light.ttf","hash":"e321c183e2b75ee19813892b7bac8d7c411cb88a","modified":1524988230969},{"_id":"public/css/fonts/roboto/Roboto-Medium.ttf","hash":"6060ca726b9760b76f7c347dce9d2fa1fe42ec92","modified":1524988230969},{"_id":"public/css/fonts/roboto/Roboto-Regular.ttf","hash":"824b5480c977a8166e177e5357d13164ccc45f47","modified":1524988230969},{"_id":"public/css/fonts/roboto/Roboto-Thin.ttf","hash":"173ed64528b4d010a76d8d38deb1d7e7eed58eda","modified":1524988230970},{"_id":"public/js/main.min.js","hash":"8acf4480f8ab859423b8926b9b790c67b5a77276","modified":1524988230978},{"_id":"public/js/search.min.js","hash":"a8a450bb8b1ca9ad577052addcbd3393f1af6c6a","modified":1524988230978},{"_id":"public/js/search.js","hash":"a1de7e7a2ef8330ebcd9f3a7a4622b3bac44e4f3","modified":1524988230979},{"_id":"public/js/main.js","hash":"300b2e963683ced162e28afcd24ffc970fc23ac2","modified":1524988230979},{"_id":"public/css/fonts/fontawesome/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1524988230979},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1524988230979},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1524988230979},{"_id":"public/css/fonts/fontawesome/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1524988231020},{"_id":"public/css/style.css","hash":"27f88e278b738328b5acd28e88b5cb20daa490e6","modified":1524988231449}],"Category":[{"name":"技术分享","_id":"cjgkim7yp0002iku7sfafjn08"},{"name":"工具安装","parent":"cjgkim7yp0002iku7sfafjn08","_id":"cjgkim7zk000biku7jwmriyja"},{"name":"基础知识","_id":"cjgkim7zu000hiku75ce2dqmu"},{"name":"算法排序","parent":"cjgkim7zu000hiku75ce2dqmu","_id":"cjgkim812001giku7gelmx6gq"}],"Data":[],"Page":[],"Post":[{"title":"Markdown语法入门","date":"2018-04-15T06:53:32.000Z","_content":"\n\n导语：\n===\nMarkdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n\n一.Markdown 官方文档  1111111111111111\n[Markdown 中文版语法说明](https://www.appinn.com/markdown/)     \n二.常用的语法规则\n\n\n# **标题**  \nMarkdown中标题如果想定义一个标题，可以在前面加上#(或者用#将标题括起来)。1-6个#分别表示1-6级标题。有的编辑器需要在#和正文之间加一个空格(Atom)，有的编译器不用(MarkdownPad)，为了保持同一建议都加上空格。  \n#标题一  \n#标题一#  \n##标题二  \n显示结果:\n# 标题一\n# 标题一 #\n## 标题二\n\n# **文本样式**\nMarkdown支持4中文本样式，分别是：  加粗.斜体.  删除线. 加粗且斜体。\n| 样式名称 | 样例 | 输出效果 |  \n| :--:   | :---:   | :--: |  \n|加粗|** 加粗 **|**加粗**|   \n|斜体|* 斜体 *|*斜体*|  \n|删除线|~~ 删除线~~ |~~删除线~~ |  \n|加粗并斜体|** _ 加粗并斜体 _ **|**_加粗并斜体_**|\n\n# **列表**\n\n在Markdown 下，无序列表直接在文字前加 「 - 」 或者 「 * 」 即可，有序列表则直接在文字前加 「1.」「2.」「3.」 。符号要和文字之间加上一个字符的空格。\n\n无序列表： 在文本前加 「 * 」 即可生成一个无序列表。快捷键：control + L （只能生成列表，不能生成子列表）\n在 「 * 」 前加两个空格键或者一个 tab 键就可以产生一个子列表。\n有序列表： 在文本前加 「字母.」 或 「数字.」 即可生成一个有序列表。\n注意，当你第一个序号使用什么作为标记的，那么同级别的列表就会自动使用其作为标记。\n无序列表和有序列表  \n\n*引用\n\n只要在文本内容之前加 「 > （大于号）」 即可将文本变成引用文本。快捷键：control + Q\n\n\n*图片与链接\n\n如果只是简单的插入图片和连接，那么非常简单。两者仅仅是一个 「 ! 」 的区别。\n\n图片\n![图片描述](链接的地址)\n快捷键：control + shift + I  \n** 链接 **\n[文本内容](链接的地址)\n快捷键：control + shift + L\n图片和链接  \n\n*水平线  \n三个「 - 」或「 * 」都可以画出一条水平分割线\n\n水平线\n*代码框\n\n两对「 ``` 」包裹\n代码前加四个空格键\n代码前加一个 tab 键\n注意，简书上需空一行后，在代码前加四个空格键或者两个 tab 键才可以生成代码框。\n有点遗憾的是，笔者未能找到让代码显示行数的方法。\n代码框\n*表格\n\n在 Markdown 下制作表格，是非常非常麻烦的一件事——你必须画出来！\n\n表格\n*脚注\n\n脚注总是成对出现的，「 [^1] 」作为标记，可以点击跳至末尾注解。「 [^1]: 」填写注解，不论写在什么位置，都会出现在文章的末尾。\n\n脚注\n注释\n\n注释是给自己看的，预览时也不会出现，当然发布出去别人也不会看见。\n快捷键：command + /\n\n注释\n首行缩进\n\n关于首行缩进，网上争议很多，而技术本身并没有错，不是吗？\n在输入法的「全角」模式下，输入两个空格键即可。\n\n首行缩进\n引号\n\n在网页上写文章建议使用直角引号『「」』。\n\n\n","source":"_posts/Markdown语法入门.md","raw":"---\ntitle: Markdown语法入门\ndate: 2018-04-15 14:53:32\ntags: \n- 工具安装\n- 操作系统\ncategories: \n- 技术分享\n- 工具安装\n---\n\n\n导语：\n===\nMarkdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n\n一.Markdown 官方文档  1111111111111111\n[Markdown 中文版语法说明](https://www.appinn.com/markdown/)     \n二.常用的语法规则\n\n\n# **标题**  \nMarkdown中标题如果想定义一个标题，可以在前面加上#(或者用#将标题括起来)。1-6个#分别表示1-6级标题。有的编辑器需要在#和正文之间加一个空格(Atom)，有的编译器不用(MarkdownPad)，为了保持同一建议都加上空格。  \n#标题一  \n#标题一#  \n##标题二  \n显示结果:\n# 标题一\n# 标题一 #\n## 标题二\n\n# **文本样式**\nMarkdown支持4中文本样式，分别是：  加粗.斜体.  删除线. 加粗且斜体。\n| 样式名称 | 样例 | 输出效果 |  \n| :--:   | :---:   | :--: |  \n|加粗|** 加粗 **|**加粗**|   \n|斜体|* 斜体 *|*斜体*|  \n|删除线|~~ 删除线~~ |~~删除线~~ |  \n|加粗并斜体|** _ 加粗并斜体 _ **|**_加粗并斜体_**|\n\n# **列表**\n\n在Markdown 下，无序列表直接在文字前加 「 - 」 或者 「 * 」 即可，有序列表则直接在文字前加 「1.」「2.」「3.」 。符号要和文字之间加上一个字符的空格。\n\n无序列表： 在文本前加 「 * 」 即可生成一个无序列表。快捷键：control + L （只能生成列表，不能生成子列表）\n在 「 * 」 前加两个空格键或者一个 tab 键就可以产生一个子列表。\n有序列表： 在文本前加 「字母.」 或 「数字.」 即可生成一个有序列表。\n注意，当你第一个序号使用什么作为标记的，那么同级别的列表就会自动使用其作为标记。\n无序列表和有序列表  \n\n*引用\n\n只要在文本内容之前加 「 > （大于号）」 即可将文本变成引用文本。快捷键：control + Q\n\n\n*图片与链接\n\n如果只是简单的插入图片和连接，那么非常简单。两者仅仅是一个 「 ! 」 的区别。\n\n图片\n![图片描述](链接的地址)\n快捷键：control + shift + I  \n** 链接 **\n[文本内容](链接的地址)\n快捷键：control + shift + L\n图片和链接  \n\n*水平线  \n三个「 - 」或「 * 」都可以画出一条水平分割线\n\n水平线\n*代码框\n\n两对「 ``` 」包裹\n代码前加四个空格键\n代码前加一个 tab 键\n注意，简书上需空一行后，在代码前加四个空格键或者两个 tab 键才可以生成代码框。\n有点遗憾的是，笔者未能找到让代码显示行数的方法。\n代码框\n*表格\n\n在 Markdown 下制作表格，是非常非常麻烦的一件事——你必须画出来！\n\n表格\n*脚注\n\n脚注总是成对出现的，「 [^1] 」作为标记，可以点击跳至末尾注解。「 [^1]: 」填写注解，不论写在什么位置，都会出现在文章的末尾。\n\n脚注\n注释\n\n注释是给自己看的，预览时也不会出现，当然发布出去别人也不会看见。\n快捷键：command + /\n\n注释\n首行缩进\n\n关于首行缩进，网上争议很多，而技术本身并没有错，不是吗？\n在输入法的「全角」模式下，输入两个空格键即可。\n\n首行缩进\n引号\n\n在网页上写文章建议使用直角引号『「」』。\n\n\n","slug":"Markdown语法入门","published":1,"updated":"2018-04-29T06:42:46.994Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgkim7yb0000iku7e7qeoyvr","content":"<h1 id=\"导语：\"><a href=\"#导语：\" class=\"headerlink\" title=\"导语：\"></a>导语：</h1><p>Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>\n<p>一.Markdown 官方文档  1111111111111111<br><a href=\"https://www.appinn.com/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown 中文版语法说明</a><br>二.常用的语法规则</p>\n<h1 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a><strong>标题</strong></h1><p>Markdown中标题如果想定义一个标题，可以在前面加上#(或者用#将标题括起来)。1-6个#分别表示1-6级标题。有的编辑器需要在#和正文之间加一个空格(Atom)，有的编译器不用(MarkdownPad)，为了保持同一建议都加上空格。  </p>\n<p>#标题一  </p>\n<p>#标题一#  </p>\n<p>##标题二<br>显示结果:</p>\n<h1 id=\"标题一\"><a href=\"#标题一\" class=\"headerlink\" title=\"标题一\"></a>标题一</h1><h1 id=\"标题一-1\"><a href=\"#标题一-1\" class=\"headerlink\" title=\"标题一\"></a>标题一</h1><h2 id=\"标题二\"><a href=\"#标题二\" class=\"headerlink\" title=\"标题二\"></a>标题二</h2><h1 id=\"文本样式\"><a href=\"#文本样式\" class=\"headerlink\" title=\"文本样式\"></a><strong>文本样式</strong></h1><p>Markdown支持4中文本样式，分别是：  加粗.斜体.  删除线. 加粗且斜体。<br>| 样式名称 | 样例 | 输出效果 |<br>| :–:   | :—:   | :–: |<br>|加粗|<strong> 加粗 </strong>|<strong>加粗</strong>|<br>|斜体|<em> 斜体 </em>|<em>斜体</em>|<br>|删除线|~~ 删除线~~ |<del>删除线</del> |<br>|加粗并斜体|<strong> _ 加粗并斜体 _ </strong>|<strong><em>加粗并斜体</em></strong>|</p>\n<h1 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a><strong>列表</strong></h1><p>在Markdown 下，无序列表直接在文字前加 「 - 」 或者 「 * 」 即可，有序列表则直接在文字前加 「1.」「2.」「3.」 。符号要和文字之间加上一个字符的空格。</p>\n<p>无序列表： 在文本前加 「 <em> 」 即可生成一个无序列表。快捷键：control + L （只能生成列表，不能生成子列表）<br>在 「 </em> 」 前加两个空格键或者一个 tab 键就可以产生一个子列表。<br>有序列表： 在文本前加 「字母.」 或 「数字.」 即可生成一个有序列表。<br>注意，当你第一个序号使用什么作为标记的，那么同级别的列表就会自动使用其作为标记。<br>无序列表和有序列表  </p>\n<p>*引用</p>\n<p>只要在文本内容之前加 「 &gt; （大于号）」 即可将文本变成引用文本。快捷键：control + Q</p>\n<p>*图片与链接</p>\n<p>如果只是简单的插入图片和连接，那么非常简单。两者仅仅是一个 「 ! 」 的区别。</p>\n<p>图片<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"链接的地址\" alt=\"图片描述\" title=\"\">\n                </div>\n                <div class=\"image-caption\">图片描述</div>\n            </figure><br>快捷键：control + shift + I<br><strong> 链接 </strong><br><a href=\"链接的地址\">文本内容</a><br>快捷键：control + shift + L<br>图片和链接  </p>\n<p><em>水平线<br>三个「 - 」或「 </em> 」都可以画出一条水平分割线</p>\n<p>水平线<br>*代码框</p>\n<p>两对「 <code>`</code> 」包裹<br>代码前加四个空格键<br>代码前加一个 tab 键<br>注意，简书上需空一行后，在代码前加四个空格键或者两个 tab 键才可以生成代码框。<br>有点遗憾的是，笔者未能找到让代码显示行数的方法。<br>代码框<br>*表格</p>\n<p>在 Markdown 下制作表格，是非常非常麻烦的一件事——你必须画出来！</p>\n<p>表格<br>*脚注</p>\n<p>脚注总是成对出现的，「 [^1] 」作为标记，可以点击跳至末尾注解。「 [^1]: 」填写注解，不论写在什么位置，都会出现在文章的末尾。</p>\n<p>脚注<br>注释</p>\n<p>注释是给自己看的，预览时也不会出现，当然发布出去别人也不会看见。<br>快捷键：command + /</p>\n<p>注释<br>首行缩进</p>\n<p>关于首行缩进，网上争议很多，而技术本身并没有错，不是吗？<br>在输入法的「全角」模式下，输入两个空格键即可。</p>\n<p>首行缩进<br>引号</p>\n<p>在网页上写文章建议使用直角引号『「」』。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"导语：\"><a href=\"#导语：\" class=\"headerlink\" title=\"导语：\"></a>导语：</h1><p>Markdown 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>\n<p>一.Markdown 官方文档  1111111111111111<br><a href=\"https://www.appinn.com/markdown/\" target=\"_blank\" rel=\"noopener\">Markdown 中文版语法说明</a><br>二.常用的语法规则</p>\n<h1 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a><strong>标题</strong></h1><p>Markdown中标题如果想定义一个标题，可以在前面加上#(或者用#将标题括起来)。1-6个#分别表示1-6级标题。有的编辑器需要在#和正文之间加一个空格(Atom)，有的编译器不用(MarkdownPad)，为了保持同一建议都加上空格。  </p>\n<p>#标题一  </p>\n<p>#标题一#  </p>\n<p>##标题二<br>显示结果:</p>\n<h1 id=\"标题一\"><a href=\"#标题一\" class=\"headerlink\" title=\"标题一\"></a>标题一</h1><h1 id=\"标题一-1\"><a href=\"#标题一-1\" class=\"headerlink\" title=\"标题一\"></a>标题一</h1><h2 id=\"标题二\"><a href=\"#标题二\" class=\"headerlink\" title=\"标题二\"></a>标题二</h2><h1 id=\"文本样式\"><a href=\"#文本样式\" class=\"headerlink\" title=\"文本样式\"></a><strong>文本样式</strong></h1><p>Markdown支持4中文本样式，分别是：  加粗.斜体.  删除线. 加粗且斜体。<br>| 样式名称 | 样例 | 输出效果 |<br>| :–:   | :—:   | :–: |<br>|加粗|<strong> 加粗 </strong>|<strong>加粗</strong>|<br>|斜体|<em> 斜体 </em>|<em>斜体</em>|<br>|删除线|~~ 删除线~~ |<del>删除线</del> |<br>|加粗并斜体|<strong> _ 加粗并斜体 _ </strong>|<strong><em>加粗并斜体</em></strong>|</p>\n<h1 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a><strong>列表</strong></h1><p>在Markdown 下，无序列表直接在文字前加 「 - 」 或者 「 * 」 即可，有序列表则直接在文字前加 「1.」「2.」「3.」 。符号要和文字之间加上一个字符的空格。</p>\n<p>无序列表： 在文本前加 「 <em> 」 即可生成一个无序列表。快捷键：control + L （只能生成列表，不能生成子列表）<br>在 「 </em> 」 前加两个空格键或者一个 tab 键就可以产生一个子列表。<br>有序列表： 在文本前加 「字母.」 或 「数字.」 即可生成一个有序列表。<br>注意，当你第一个序号使用什么作为标记的，那么同级别的列表就会自动使用其作为标记。<br>无序列表和有序列表  </p>\n<p>*引用</p>\n<p>只要在文本内容之前加 「 &gt; （大于号）」 即可将文本变成引用文本。快捷键：control + Q</p>\n<p>*图片与链接</p>\n<p>如果只是简单的插入图片和连接，那么非常简单。两者仅仅是一个 「 ! 」 的区别。</p>\n<p>图片<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"链接的地址\" alt=\"图片描述\" title=\"\">\n                </div>\n                <div class=\"image-caption\">图片描述</div>\n            </figure><br>快捷键：control + shift + I<br><strong> 链接 </strong><br><a href=\"链接的地址\">文本内容</a><br>快捷键：control + shift + L<br>图片和链接  </p>\n<p><em>水平线<br>三个「 - 」或「 </em> 」都可以画出一条水平分割线</p>\n<p>水平线<br>*代码框</p>\n<p>两对「 <code>`</code> 」包裹<br>代码前加四个空格键<br>代码前加一个 tab 键<br>注意，简书上需空一行后，在代码前加四个空格键或者两个 tab 键才可以生成代码框。<br>有点遗憾的是，笔者未能找到让代码显示行数的方法。<br>代码框<br>*表格</p>\n<p>在 Markdown 下制作表格，是非常非常麻烦的一件事——你必须画出来！</p>\n<p>表格<br>*脚注</p>\n<p>脚注总是成对出现的，「 [^1] 」作为标记，可以点击跳至末尾注解。「 [^1]: 」填写注解，不论写在什么位置，都会出现在文章的末尾。</p>\n<p>脚注<br>注释</p>\n<p>注释是给自己看的，预览时也不会出现，当然发布出去别人也不会看见。<br>快捷键：command + /</p>\n<p>注释<br>首行缩进</p>\n<p>关于首行缩进，网上争议很多，而技术本身并没有错，不是吗？<br>在输入法的「全角」模式下，输入两个空格键即可。</p>\n<p>首行缩进<br>引号</p>\n<p>在网页上写文章建议使用直角引号『「」』。</p>\n"},{"layout":"blog","title":"Nihao,blog","date":"2018-04-21T14:09:32.000Z","_content":"","source":"_posts/Nihao-blog.md","raw":"---\nlayout: blog\ntitle: 'Nihao,blog'\ndate: 2018-04-21 22:09:32\ntags:\n---\n","slug":"Nihao-blog","published":1,"updated":"2018-04-29T06:42:47.004Z","comments":1,"photos":[],"link":"","_id":"cjgkim7ym0001iku7w8c386j3","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"虚拟机qqqqqqqqqqqqqq","date":"2018-04-16T15:20:40.000Z","_content":"\n\n# 设置虚拟机参数\n## 小标题1\n1. 打开vmware workstations，`文件->新建虚拟机`，出现如下界面，选择`自定义（高级）`选项，下一步继续：               ffffffffffffff\n{% asset_img 1.jpg [选择操作系统镜像] %}\n\n2. 打sffser开vmware workstations，`文件->新建虚拟机`，出现如下界面，选择`自定义（高级）`选项，下一步继续fffffffffffffssssss：\n{% asset_img 1.jpg [选择操作系统镜像] %}\n\n\n# 设置CentOS参数\n1. 打开vmware workstations，`文件->新建虚拟机`，出现如下界面，选择`自定义（高级）`选项，下一步继续：\n{% asset_img 1.jpg [选择操作系统镜像] %}\n","source":"_posts/new.md","raw":"---\ntitle: 虚拟机qqqqqqqqqqqqqq\ntags: \n- 工具安装\n- 操作系统\ncategories: \n- 技术分享\n- 工具安装\ndate: 2018-04-16 23:20:40\n---\n\n\n# 设置虚拟机参数\n## 小标题1\n1. 打开vmware workstations，`文件->新建虚拟机`，出现如下界面，选择`自定义（高级）`选项，下一步继续：               ffffffffffffff\n{% asset_img 1.jpg [选择操作系统镜像] %}\n\n2. 打sffser开vmware workstations，`文件->新建虚拟机`，出现如下界面，选择`自定义（高级）`选项，下一步继续fffffffffffffssssss：\n{% asset_img 1.jpg [选择操作系统镜像] %}\n\n\n# 设置CentOS参数\n1. 打开vmware workstations，`文件->新建虚拟机`，出现如下界面，选择`自定义（高级）`选项，下一步继续：\n{% asset_img 1.jpg [选择操作系统镜像] %}\n","slug":"new","published":1,"updated":"2018-04-29T06:42:47.027Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgkim7yv0004iku7g8sf4vtc","content":"<h1 id=\"设置虚拟机参数\"><a href=\"#设置虚拟机参数\" class=\"headerlink\" title=\"设置虚拟机参数\"></a>设置虚拟机参数</h1><h2 id=\"小标题1\"><a href=\"#小标题1\" class=\"headerlink\" title=\"小标题1\"></a>小标题1</h2><ol>\n<li><p>打开vmware workstations，<code>文件-&gt;新建虚拟机</code>，出现如下界面，选择<code>自定义（高级）</code>选项，下一步继续：               ffffffffffffff</p>\n\n</li>\n<li><p>打sffser开vmware workstations，<code>文件-&gt;新建虚拟机</code>，出现如下界面，选择<code>自定义（高级）</code>选项，下一步继续fffffffffffffssssss：</p>\n\n</li>\n</ol>\n<h1 id=\"设置CentOS参数\"><a href=\"#设置CentOS参数\" class=\"headerlink\" title=\"设置CentOS参数\"></a>设置CentOS参数</h1><ol>\n<li>打开vmware workstations，<code>文件-&gt;新建虚拟机</code>，出现如下界面，选择<code>自定义（高级）</code>选项，下一步继续：\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"设置虚拟机参数\"><a href=\"#设置虚拟机参数\" class=\"headerlink\" title=\"设置虚拟机参数\"></a>设置虚拟机参数</h1><h2 id=\"小标题1\"><a href=\"#小标题1\" class=\"headerlink\" title=\"小标题1\"></a>小标题1</h2><ol>\n<li><p>打开vmware workstations，<code>文件-&gt;新建虚拟机</code>，出现如下界面，选择<code>自定义（高级）</code>选项，下一步继续：               ffffffffffffff</p>\n\n</li>\n<li><p>打sffser开vmware workstations，<code>文件-&gt;新建虚拟机</code>，出现如下界面，选择<code>自定义（高级）</code>选项，下一步继续fffffffffffffssssss：</p>\n\n</li>\n</ol>\n<h1 id=\"设置CentOS参数\"><a href=\"#设置CentOS参数\" class=\"headerlink\" title=\"设置CentOS参数\"></a>设置CentOS参数</h1><ol>\n<li>打开vmware workstations，<code>文件-&gt;新建虚拟机</code>，出现如下界面，选择<code>自定义（高级）</code>选项，下一步继续：\n</li>\n</ol>\n"},{"_content":"相关步骤：\n1、安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下\n\n \n 2、安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择\n \n\n注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的界面如图\n\n \n 3、Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README\n\n \n在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。 \n\n \n 4、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面\n\n \n输入npm install hexo -g，开始安装Hexo\n\n \n输入hexo -v，检查hexo是否安装成功\n\n \n输入hexo init，初始化该文件夹（有点漫长的等待。。。）\n\n\n\n看到后面的“Start blogging with Hexo！”，激动有木有！！！！！\n \n输入npm install，安装所需要的组件\n\n \n输入hexo g，首次体验Hexo\n\n \n 输入hexo s，开启服务器，访问该网址，正式体验Hexo\n\n问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号\n\n那么出现如下图就成功了\n\n \n \n 5、将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次的话）\n \n\n上图是在其文件夹里面鼠标右键，点击Git Base Here。这里“feng”可以替换成自己的用户名，邮箱可以替换成自己的邮箱\n \n输入cd ~/.ssh，检查是否由.ssh的文件夹\n\n \n输入ls，列出该文件下的内容。下图说明存在\n\n \n 输入ssh-keygen -t rsa -C “929762930@qq.com”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\\Users\\Administrator\\.ssh）。\n \n\n \n 输入eval \"$(ssh-agent -s)\"，添加密钥到ssh-agent\n\n \n 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent\n\n \n 登录Github，点击头像下的settings，添加ssh\n \n\n \n新建一个new ssh key，将id_rsa.pub文件里的内容复制上去\n\n \n输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了\n\n问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决\n首先，清除所有的key-pair\nssh-add -D\nrm -r ~/.ssh\n删除你在github中的public-key\n重新生成ssh密钥对\nssh-keygen -t rsa -C \"xxx@xxx.com\"\n接下来正常操作\n在github上添加公钥public-key:\n1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板\n2、在github上添加公钥时，直接复制即可\n3、保存\n测试：\n在终端 ssh -T git@github.com\n \n6、配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾）\n \n\n \nrepo值是你在github项目里的ssh（右下角）\n\n \n7、新建一篇博客，在cmd执行命令：hexo new post “博客名”\n\n \n 这时候在文件夹_posts目录下将会看到已经创建的文件\n\n \n在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git --save\n\n \n使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了\n \n\n \n部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章\n\n \n 好了，到此为止，最基本的也是最全面的hexo+github搭建博客完结。\n","source":"_posts/使用Github和Hexo搭建博客.md","raw":"相关步骤：\n1、安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下\n\n \n 2、安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择\n \n\n注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的界面如图\n\n \n 3、Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README\n\n \n在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。 \n\n \n 4、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面\n\n \n输入npm install hexo -g，开始安装Hexo\n\n \n输入hexo -v，检查hexo是否安装成功\n\n \n输入hexo init，初始化该文件夹（有点漫长的等待。。。）\n\n\n\n看到后面的“Start blogging with Hexo！”，激动有木有！！！！！\n \n输入npm install，安装所需要的组件\n\n \n输入hexo g，首次体验Hexo\n\n \n 输入hexo s，开启服务器，访问该网址，正式体验Hexo\n\n问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号\n\n那么出现如下图就成功了\n\n \n \n 5、将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次的话）\n \n\n上图是在其文件夹里面鼠标右键，点击Git Base Here。这里“feng”可以替换成自己的用户名，邮箱可以替换成自己的邮箱\n \n输入cd ~/.ssh，检查是否由.ssh的文件夹\n\n \n输入ls，列出该文件下的内容。下图说明存在\n\n \n 输入ssh-keygen -t rsa -C “929762930@qq.com”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\\Users\\Administrator\\.ssh）。\n \n\n \n 输入eval \"$(ssh-agent -s)\"，添加密钥到ssh-agent\n\n \n 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent\n\n \n 登录Github，点击头像下的settings，添加ssh\n \n\n \n新建一个new ssh key，将id_rsa.pub文件里的内容复制上去\n\n \n输入ssh -T git@github.com，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了\n\n问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决\n首先，清除所有的key-pair\nssh-add -D\nrm -r ~/.ssh\n删除你在github中的public-key\n重新生成ssh密钥对\nssh-keygen -t rsa -C \"xxx@xxx.com\"\n接下来正常操作\n在github上添加公钥public-key:\n1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板\n2、在github上添加公钥时，直接复制即可\n3、保存\n测试：\n在终端 ssh -T git@github.com\n \n6、配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾）\n \n\n \nrepo值是你在github项目里的ssh（右下角）\n\n \n7、新建一篇博客，在cmd执行命令：hexo new post “博客名”\n\n \n 这时候在文件夹_posts目录下将会看到已经创建的文件\n\n \n在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git --save\n\n \n使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了\n \n\n \n部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章\n\n \n 好了，到此为止，最基本的也是最全面的hexo+github搭建博客完结。\n","slug":"使用Github和Hexo搭建博客","published":1,"date":"2018-04-29T06:42:47.031Z","updated":"2018-04-29T06:42:47.032Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgkim7yz0005iku7g1e54ego","content":"<p>相关步骤：<br>1、安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下</p>\n<p> 2、安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择</p>\n<p>注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的界面如图</p>\n<p> 3、Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README</p>\n<p>在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。 </p>\n<p> 4、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面</p>\n<p>输入npm install hexo -g，开始安装Hexo</p>\n<p>输入hexo -v，检查hexo是否安装成功</p>\n<p>输入hexo init，初始化该文件夹（有点漫长的等待。。。）</p>\n<p>看到后面的“Start blogging with Hexo！”，激动有木有！！！！！</p>\n<p>输入npm install，安装所需要的组件</p>\n<p>输入hexo g，首次体验Hexo</p>\n<p> 输入hexo s，开启服务器，访问该网址，正式体验Hexo</p>\n<p>问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号</p>\n<p>那么出现如下图就成功了</p>\n<p> 5、将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次的话）</p>\n<p>上图是在其文件夹里面鼠标右键，点击Git Base Here。这里“feng”可以替换成自己的用户名，邮箱可以替换成自己的邮箱</p>\n<p>输入cd ~/.ssh，检查是否由.ssh的文件夹</p>\n<p>输入ls，列出该文件下的内容。下图说明存在</p>\n<p> 输入ssh-keygen -t rsa -C “<a href=\"mailto:929762930@qq.com\" target=\"_blank\" rel=\"noopener\">929762930@qq.com</a>”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\\Users\\Administrator.ssh）。</p>\n<p> 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent</p>\n<p> 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent</p>\n<p> 登录Github，点击头像下的settings，添加ssh</p>\n<p>新建一个new ssh key，将id_rsa.pub文件里的内容复制上去</p>\n<p>输入ssh -T <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了</p>\n<p>问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决<br>首先，清除所有的key-pair<br>ssh-add -D<br>rm -r ~/.ssh<br>删除你在github中的public-key<br>重新生成ssh密钥对<br>ssh-keygen -t rsa -C “<a href=\"mailto:xxx@xxx.com\" target=\"_blank\" rel=\"noopener\">xxx@xxx.com</a>“<br>接下来正常操作<br>在github上添加公钥public-key:<br>1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板<br>2、在github上添加公钥时，直接复制即可<br>3、保存<br>测试：<br>在终端 ssh -T <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a></p>\n<p>6、配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾）</p>\n<p>repo值是你在github项目里的ssh（右下角）</p>\n<p>7、新建一篇博客，在cmd执行命令：hexo new post “博客名”</p>\n<p> 这时候在文件夹_posts目录下将会看到已经创建的文件</p>\n<p>在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save</p>\n<p>使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了</p>\n<p>部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章</p>\n<p> 好了，到此为止，最基本的也是最全面的hexo+github搭建博客完结。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>相关步骤：<br>1、安装Node.js和配置好Node.js环境，打开cmd命令行，成功界面如下</p>\n<p> 2、安装Git和配置好Git环境，安装成功的象征就是在电脑上任何位置鼠标右键能够出现如下两个选择</p>\n<p>注意：一般出于安全考虑，只有在Git Bash Here中才能进行Git的相关操作。如果需要在cmd命令行里调用Git，那么就要配置电脑的环境变量Path，或者在安装的时候选择use Git from the Windows Command Prompt。这个可有可无，影响不大，成功配置的界面如图</p>\n<p> 3、Github账户注册和新建项目，项目必须要遵守格式：账户名.github.io，不然接下来会有很多麻烦。并且需要勾选Initialize this repository with a README</p>\n<p>在建好的项目右侧有个settings按钮，点击它，向下拉到GitHub Pages，你会看到那边有个网址，访问它，你将会惊奇的发现该项目已经被部署到网络上，能够通过外网来访问它。 </p>\n<p> 4、安装Hexo，在自己认为合适的地方创个文件夹，我是在D盘建了一个blog文件夹。然后通过命令行进入到该文件夹里面</p>\n<p>输入npm install hexo -g，开始安装Hexo</p>\n<p>输入hexo -v，检查hexo是否安装成功</p>\n<p>输入hexo init，初始化该文件夹（有点漫长的等待。。。）</p>\n<p>看到后面的“Start blogging with Hexo！”，激动有木有！！！！！</p>\n<p>输入npm install，安装所需要的组件</p>\n<p>输入hexo g，首次体验Hexo</p>\n<p> 输入hexo s，开启服务器，访问该网址，正式体验Hexo</p>\n<p>问题：假如页面一直无法跳转，那么可能端口被占用了。此时我们ctrl+c停止服务器，接着输入“hexo server -p 端口号”来改变端口号</p>\n<p>那么出现如下图就成功了</p>\n<p> 5、将Hexo与Github page联系起来，设置Git的user name和email（如果是第一次的话）</p>\n<p>上图是在其文件夹里面鼠标右键，点击Git Base Here。这里“feng”可以替换成自己的用户名，邮箱可以替换成自己的邮箱</p>\n<p>输入cd ~/.ssh，检查是否由.ssh的文件夹</p>\n<p>输入ls，列出该文件下的内容。下图说明存在</p>\n<p> 输入ssh-keygen -t rsa -C “<a href=\"mailto:929762930@qq.com\" target=\"_blank\" rel=\"noopener\">929762930@qq.com</a>”，连续三个回车，生成密钥，最后得到了两个文件：id_rsa和id_rsa.pub（默认存储路径是：C:\\Users\\Administrator.ssh）。</p>\n<p> 输入eval “$(ssh-agent -s)”，添加密钥到ssh-agent</p>\n<p> 再输入ssh-add ~/.ssh/id_rsa，添加生成的SSH key到ssh-agent</p>\n<p> 登录Github，点击头像下的settings，添加ssh</p>\n<p>新建一个new ssh key，将id_rsa.pub文件里的内容复制上去</p>\n<p>输入ssh -T <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>，测试添加ssh是否成功。如果看到Hi后面是你的用户名，就说明成功了</p>\n<p>问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决<br>首先，清除所有的key-pair<br>ssh-add -D<br>rm -r ~/.ssh<br>删除你在github中的public-key<br>重新生成ssh密钥对<br>ssh-keygen -t rsa -C “<a href=\"mailto:xxx@xxx.com\" target=\"_blank\" rel=\"noopener\">xxx@xxx.com</a>“<br>接下来正常操作<br>在github上添加公钥public-key:<br>1、首先在你的终端运行 xclip -sel c ~/.ssh/id_rsa.pub将公钥内容复制到剪切板<br>2、在github上添加公钥时，直接复制即可<br>3、保存<br>测试：<br>在终端 ssh -T <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a></p>\n<p>6、配置Deployment，在其文件夹中，找到_config.yml文件，修改repo值（在末尾）</p>\n<p>repo值是你在github项目里的ssh（右下角）</p>\n<p>7、新建一篇博客，在cmd执行命令：hexo new post “博客名”</p>\n<p> 这时候在文件夹_posts目录下将会看到已经创建的文件</p>\n<p>在生成以及部署文章之前，需要安装一个扩展：npm install hexo-deployer-git –save</p>\n<p>使用编辑器编好文章，那么就可以使用命令：hexo d -g，生成以及部署了</p>\n<p>部署成功后访问你的地址：http://用户名.github.io。那么将看到生成的文章</p>\n<p> 好了，到此为止，最基本的也是最全面的hexo+github搭建博客完结。</p>\n"},{"title":"冒泡排序","date":"2018-04-16T15:20:40.000Z","_content":"\n\t1.原理：比较两个相邻的元素，将值大的元素交换至右端。\n\t思路：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。\n\t举例说明：要排序数组：int[] arr={6,3,8,2,9,1};   \n\t第一趟排序：\n\t第一次排序：6和3比较，6大于3，交换位置：  3  6  8  2  9  1\n\t第二次排序：6和8比较，6小于8，不交换位置：3  6  8  2  9  1\n\t第三次排序：8和2比较，8大于2，交换位置：  3  6  2  8  9  1\n\t第四次排序：8和9比较，8小于9，不交换位置：3  6  2  8  9  1\n\t第五次排序：9和1比较：9大于1，交换位置：  3  6  2  8  1  9\n\t第一趟总共进行了5次比较， 排序结果：      3  6  2  8  1  9\n\t---------------------------------------------------------------------\n\t第二趟排序：\n\t第一次排序：3和6比较，3小于6，不交换位置：3  6  2  8  1  9\n\t第二次排序：6和2比较，6大于2，交换位置：  3  2  6  8  1  9\n\t第三次排序：6和8比较，6大于8，不交换位置：3  2  6  8  1  9\n\t第四次排序：8和1比较，8大于1，交换位置：  3  2  6  1  8  9\n\t第二趟总共进行了4次比较， 排序结果：      3  2  6  1  8  9\n\t---------------------------------------------------------------------\n\t第三趟排序：\n\t第一次排序：3和2比较，3大于2，交换位置：  2  3  6  1  8  9\n\t第二次排序：3和6比较，3小于6，不交换位置：2  3  6  1  8  9\n\t第三次排序：6和1比较，6大于1，交换位置：  2  3  1  6  8  9\n\t第二趟总共进行了3次比较， 排序结果：         2  3  1  6  8  9\n\t---------------------------------------------------------------------\n\t第四趟排序：\n\t第一次排序：2和3比较，2小于3，不交换位置：2  3  1  6  8  9\n\t第二次排序：3和1比较，3大于1，交换位置：  2  1  3  6  8  9\n\t第二趟总共进行了2次比较， 排序结果：        2  1  3  6  8  9\n\t---------------------------------------------------------------------\n\t第五趟排序：\n\t第一次排序：2和1比较，2大于1，交换位置：  1  2  3  6  8  9\n\t第二趟总共进行了1次比较， 排序结果：  1  2  3  6  8  9\n\t---------------------------------------------------------------------\n\t最终结果：1  2  3  6  8  9\n\t---------------------------------------------------------------------\n2.代码实现\n\t代码实现： \n\t/*\n\t * 冒泡排序\n\t */\n\tpublic class BubbleSort {\n\t　　public static void  BubbleSort1(int[] arr){　　　\n\t\t\t\n\t\t\tint i = 0, j = 0;\n\t\t\tInt size=arr.length;\n\t\t\n\t\t\tfor (i = 0; i < size - 1; i++)//一共要排序size-1次\n\t\t\t{\n\t\t\t\tfor (j = 0; j < size - 1 - i; j++)//选出该趟排序的最大值往后移动\n\t\t\t\t{\n\t\t\t\t\tif (arr[j] > arr[j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tint tmp = arr[j];\n\t\t\t\t\t\tarr[j] = arr[j + 1];\n\t\t\t\t\t\tarr[j + 1] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t　　}\n\t }\n \n\n\n3、算法分析\n（1）算法的最好时间复杂度\n    　若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数C和记录移动次数M均达到最小值：\n        C(min)=n-1\n        M(min)=0。\n    　冒泡排序最好的时间复杂度为O(n)。\n \n（2）算法的最坏时间复杂度\n    　若初始文件是反序的，需要进行n-1趟排序。每趟排序要进行n-i次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：\n        C(max)=n(n-1)/2=O(n^2)\n        M(max)=3n(n-1)/2=O(n^2)\n    　冒泡排序的最坏时间复杂度为O(n^2)。\n \n（3）算法的平均时间复杂度为O(n^2)\n    　虽然冒泡排序不一定要进行n-1趟，但由于它的记录移动次数较多，故平均时间性能比直接插入排序要差得多。\n \n（4）算法稳定性\n    　冒泡排序是就地排序，且它是稳定的。\n4.优化1（优化外层循环）：\n    　若在某一趟排序中未发现气泡位置的交换，则说明待排序的无序区中所有气泡均满足轻者在上，重者在下的原则，因此，冒泡排序过程可在此趟排序后终止。为此，在下面给出的算法中，引入一个标签flag，在每趟排序开始前，先将其置为0。若排序过程中发生了交换，则将其置为1。各趟排序结束时检查flag，若未曾发生过交换则终止算法，不再进行下一趟排序。\n \n具体算法：\n1. //冒泡排序优化1  \n2. void BubbleSort2(int[] arr)  \n3. {  \n4.       \n5.     int i = 0, j = 0; \n   int size = arr.length; \n6.   \n7.     for (i = 0; i < size - 1; i++)//一共要排序size-1次  \n8.     {  \n9.         //每次遍历标志位都要先置为0，才能判断后面的元素是否发生了交换  \n10.         int flag = 0;  \n11.   \n12.         for (j = 0; j < size - 1 - i; j++)//选出该趟排序的最大值往后移动  \n13.         {  \n14.             if (arr[j] > arr[j + 1])  \n15.             {  \n16.                 int tmp = arr[j];  \n17.                 arr[j] = arr[j + 1];  \n18.                 arr[j + 1] = tmp;  \n19.                 flag = 1;//只要有发生了交换，flag就置为1  \n20.             }  \n21.         }  \n22.   \n23.         //判断标志位是否为0，如果为0，说明后面的元素已经有序，就直接return  \n24.         if (flag == 0)  \n25.         {  \n26.             return;  \n27.         }  \n28.     }  \n29.   \n30. }  \n\n5、算法优化2（优化内层循环）\n  \n   (1)记住最后一次交换发生位置lastExchange的冒泡排序\n在每趟扫描中，记住最后一次交换发生的位置lastExchange，（该位置之后的相邻记录均已有序）。下一趟排序开始时，R[1..lastExchange-1]是无序区，R[lastExchange..n]是有序区。这样，一趟排序可能使当前无序区扩充多个记录，因此记住最后一次交换发生的位置lastExchange，从而减少排序的趟数。\n具体算法：\n[cpp] \nview plain \ncopy\n31. //冒泡排序优化2  \n32. void BubbleSort3(int[] arr)  \n33. {  \n34.      \n35.     int i = 0, j = 0;\n36.       int size = arr.length;  \n37.     int k = size - 1,pos = 0;//pos变量用来标记循环里最后一次交换的位置    \n38.       \n39.     for (i = 0; i < size - 1; i++)//一共要排序size-1次  \n40.     {  \n41.         //每次遍历标志位都要先置为0，才能判断后面的元素是否发生了交换  \n42.         int flag = 0;  \n43.   \n44.         for (j = 0; j <k; j++)//选出该趟排序的最大值往后移动  \n45.         {  \n46.             if (arr[j] > arr[j + 1])  \n47.             {  \n48.                 int tmp = arr[j];  \n49.                 arr[j] = arr[j + 1];  \n50.                 arr[j + 1] = tmp;  \n51.                 flag = 1;//只要有发生了交换，flag就置为1  \n52.                 pos = j;//循环里最后一次交换的位置 j赋给pos  \n53.             }  \n54.         }  \n55.   \n56.         k = pos;  \n57.         //判断标志位是否为0，如果为0，说明后面的元素已经有序，就直接return  \n58.         if (flag == 0)  \n59.         {  \n60.             return;  \n61.         }  \n62.     }  \n63.   \n64. }  \n\n\n\n\n\n\n","source":"_posts/冒泡排序.md","raw":"---\ntitle: 冒泡排序\ntags: \n- 算法排序\n- 基础知识\ncategories: \n- 基础知识\n- 算法排序\ndate: 2018-04-16 23:20:40\n---\n\n\t1.原理：比较两个相邻的元素，将值大的元素交换至右端。\n\t思路：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。\n\t举例说明：要排序数组：int[] arr={6,3,8,2,9,1};   \n\t第一趟排序：\n\t第一次排序：6和3比较，6大于3，交换位置：  3  6  8  2  9  1\n\t第二次排序：6和8比较，6小于8，不交换位置：3  6  8  2  9  1\n\t第三次排序：8和2比较，8大于2，交换位置：  3  6  2  8  9  1\n\t第四次排序：8和9比较，8小于9，不交换位置：3  6  2  8  9  1\n\t第五次排序：9和1比较：9大于1，交换位置：  3  6  2  8  1  9\n\t第一趟总共进行了5次比较， 排序结果：      3  6  2  8  1  9\n\t---------------------------------------------------------------------\n\t第二趟排序：\n\t第一次排序：3和6比较，3小于6，不交换位置：3  6  2  8  1  9\n\t第二次排序：6和2比较，6大于2，交换位置：  3  2  6  8  1  9\n\t第三次排序：6和8比较，6大于8，不交换位置：3  2  6  8  1  9\n\t第四次排序：8和1比较，8大于1，交换位置：  3  2  6  1  8  9\n\t第二趟总共进行了4次比较， 排序结果：      3  2  6  1  8  9\n\t---------------------------------------------------------------------\n\t第三趟排序：\n\t第一次排序：3和2比较，3大于2，交换位置：  2  3  6  1  8  9\n\t第二次排序：3和6比较，3小于6，不交换位置：2  3  6  1  8  9\n\t第三次排序：6和1比较，6大于1，交换位置：  2  3  1  6  8  9\n\t第二趟总共进行了3次比较， 排序结果：         2  3  1  6  8  9\n\t---------------------------------------------------------------------\n\t第四趟排序：\n\t第一次排序：2和3比较，2小于3，不交换位置：2  3  1  6  8  9\n\t第二次排序：3和1比较，3大于1，交换位置：  2  1  3  6  8  9\n\t第二趟总共进行了2次比较， 排序结果：        2  1  3  6  8  9\n\t---------------------------------------------------------------------\n\t第五趟排序：\n\t第一次排序：2和1比较，2大于1，交换位置：  1  2  3  6  8  9\n\t第二趟总共进行了1次比较， 排序结果：  1  2  3  6  8  9\n\t---------------------------------------------------------------------\n\t最终结果：1  2  3  6  8  9\n\t---------------------------------------------------------------------\n2.代码实现\n\t代码实现： \n\t/*\n\t * 冒泡排序\n\t */\n\tpublic class BubbleSort {\n\t　　public static void  BubbleSort1(int[] arr){　　　\n\t\t\t\n\t\t\tint i = 0, j = 0;\n\t\t\tInt size=arr.length;\n\t\t\n\t\t\tfor (i = 0; i < size - 1; i++)//一共要排序size-1次\n\t\t\t{\n\t\t\t\tfor (j = 0; j < size - 1 - i; j++)//选出该趟排序的最大值往后移动\n\t\t\t\t{\n\t\t\t\t\tif (arr[j] > arr[j + 1])\n\t\t\t\t\t{\n\t\t\t\t\t\tint tmp = arr[j];\n\t\t\t\t\t\tarr[j] = arr[j + 1];\n\t\t\t\t\t\tarr[j + 1] = tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t　　}\n\t }\n \n\n\n3、算法分析\n（1）算法的最好时间复杂度\n    　若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数C和记录移动次数M均达到最小值：\n        C(min)=n-1\n        M(min)=0。\n    　冒泡排序最好的时间复杂度为O(n)。\n \n（2）算法的最坏时间复杂度\n    　若初始文件是反序的，需要进行n-1趟排序。每趟排序要进行n-i次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：\n        C(max)=n(n-1)/2=O(n^2)\n        M(max)=3n(n-1)/2=O(n^2)\n    　冒泡排序的最坏时间复杂度为O(n^2)。\n \n（3）算法的平均时间复杂度为O(n^2)\n    　虽然冒泡排序不一定要进行n-1趟，但由于它的记录移动次数较多，故平均时间性能比直接插入排序要差得多。\n \n（4）算法稳定性\n    　冒泡排序是就地排序，且它是稳定的。\n4.优化1（优化外层循环）：\n    　若在某一趟排序中未发现气泡位置的交换，则说明待排序的无序区中所有气泡均满足轻者在上，重者在下的原则，因此，冒泡排序过程可在此趟排序后终止。为此，在下面给出的算法中，引入一个标签flag，在每趟排序开始前，先将其置为0。若排序过程中发生了交换，则将其置为1。各趟排序结束时检查flag，若未曾发生过交换则终止算法，不再进行下一趟排序。\n \n具体算法：\n1. //冒泡排序优化1  \n2. void BubbleSort2(int[] arr)  \n3. {  \n4.       \n5.     int i = 0, j = 0; \n   int size = arr.length; \n6.   \n7.     for (i = 0; i < size - 1; i++)//一共要排序size-1次  \n8.     {  \n9.         //每次遍历标志位都要先置为0，才能判断后面的元素是否发生了交换  \n10.         int flag = 0;  \n11.   \n12.         for (j = 0; j < size - 1 - i; j++)//选出该趟排序的最大值往后移动  \n13.         {  \n14.             if (arr[j] > arr[j + 1])  \n15.             {  \n16.                 int tmp = arr[j];  \n17.                 arr[j] = arr[j + 1];  \n18.                 arr[j + 1] = tmp;  \n19.                 flag = 1;//只要有发生了交换，flag就置为1  \n20.             }  \n21.         }  \n22.   \n23.         //判断标志位是否为0，如果为0，说明后面的元素已经有序，就直接return  \n24.         if (flag == 0)  \n25.         {  \n26.             return;  \n27.         }  \n28.     }  \n29.   \n30. }  \n\n5、算法优化2（优化内层循环）\n  \n   (1)记住最后一次交换发生位置lastExchange的冒泡排序\n在每趟扫描中，记住最后一次交换发生的位置lastExchange，（该位置之后的相邻记录均已有序）。下一趟排序开始时，R[1..lastExchange-1]是无序区，R[lastExchange..n]是有序区。这样，一趟排序可能使当前无序区扩充多个记录，因此记住最后一次交换发生的位置lastExchange，从而减少排序的趟数。\n具体算法：\n[cpp] \nview plain \ncopy\n31. //冒泡排序优化2  \n32. void BubbleSort3(int[] arr)  \n33. {  \n34.      \n35.     int i = 0, j = 0;\n36.       int size = arr.length;  \n37.     int k = size - 1,pos = 0;//pos变量用来标记循环里最后一次交换的位置    \n38.       \n39.     for (i = 0; i < size - 1; i++)//一共要排序size-1次  \n40.     {  \n41.         //每次遍历标志位都要先置为0，才能判断后面的元素是否发生了交换  \n42.         int flag = 0;  \n43.   \n44.         for (j = 0; j <k; j++)//选出该趟排序的最大值往后移动  \n45.         {  \n46.             if (arr[j] > arr[j + 1])  \n47.             {  \n48.                 int tmp = arr[j];  \n49.                 arr[j] = arr[j + 1];  \n50.                 arr[j + 1] = tmp;  \n51.                 flag = 1;//只要有发生了交换，flag就置为1  \n52.                 pos = j;//循环里最后一次交换的位置 j赋给pos  \n53.             }  \n54.         }  \n55.   \n56.         k = pos;  \n57.         //判断标志位是否为0，如果为0，说明后面的元素已经有序，就直接return  \n58.         if (flag == 0)  \n59.         {  \n60.             return;  \n61.         }  \n62.     }  \n63.   \n64. }  \n\n\n\n\n\n\n","slug":"冒泡排序","published":1,"updated":"2018-04-29T06:42:47.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgkim7z30006iku75osu9iv6","content":"<pre><code>1.原理：比较两个相邻的元素，将值大的元素交换至右端。\n思路：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。\n举例说明：要排序数组：int[] arr={6,3,8,2,9,1};   \n第一趟排序：\n第一次排序：6和3比较，6大于3，交换位置：  3  6  8  2  9  1\n第二次排序：6和8比较，6小于8，不交换位置：3  6  8  2  9  1\n第三次排序：8和2比较，8大于2，交换位置：  3  6  2  8  9  1\n第四次排序：8和9比较，8小于9，不交换位置：3  6  2  8  9  1\n第五次排序：9和1比较：9大于1，交换位置：  3  6  2  8  1  9\n第一趟总共进行了5次比较， 排序结果：      3  6  2  8  1  9\n---------------------------------------------------------------------\n第二趟排序：\n第一次排序：3和6比较，3小于6，不交换位置：3  6  2  8  1  9\n第二次排序：6和2比较，6大于2，交换位置：  3  2  6  8  1  9\n第三次排序：6和8比较，6大于8，不交换位置：3  2  6  8  1  9\n第四次排序：8和1比较，8大于1，交换位置：  3  2  6  1  8  9\n第二趟总共进行了4次比较， 排序结果：      3  2  6  1  8  9\n---------------------------------------------------------------------\n第三趟排序：\n第一次排序：3和2比较，3大于2，交换位置：  2  3  6  1  8  9\n第二次排序：3和6比较，3小于6，不交换位置：2  3  6  1  8  9\n第三次排序：6和1比较，6大于1，交换位置：  2  3  1  6  8  9\n第二趟总共进行了3次比较， 排序结果：         2  3  1  6  8  9\n---------------------------------------------------------------------\n第四趟排序：\n第一次排序：2和3比较，2小于3，不交换位置：2  3  1  6  8  9\n第二次排序：3和1比较，3大于1，交换位置：  2  1  3  6  8  9\n第二趟总共进行了2次比较， 排序结果：        2  1  3  6  8  9\n---------------------------------------------------------------------\n第五趟排序：\n第一次排序：2和1比较，2大于1，交换位置：  1  2  3  6  8  9\n第二趟总共进行了1次比较， 排序结果：  1  2  3  6  8  9\n---------------------------------------------------------------------\n最终结果：1  2  3  6  8  9\n---------------------------------------------------------------------\n</code></pre><p>2.代码实现<br>    代码实现：<br>    /*</p>\n<pre><code> * 冒泡排序\n */\npublic class BubbleSort {\n　　public static void  BubbleSort1(int[] arr){　　　\n\n        int i = 0, j = 0;\n        Int size=arr.length;\n\n        for (i = 0; i &lt; size - 1; i++)//一共要排序size-1次\n        {\n            for (j = 0; j &lt; size - 1 - i; j++)//选出该趟排序的最大值往后移动\n            {\n                if (arr[j] &gt; arr[j + 1])\n                {\n                    int tmp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = tmp;\n                }\n            }\n        }\n　　}\n }\n</code></pre><p>3、算法分析<br>（1）算法的最好时间复杂度<br>    　若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数C和记录移动次数M均达到最小值：<br>        C(min)=n-1<br>        M(min)=0。<br>    　冒泡排序最好的时间复杂度为O(n)。</p>\n<p>（2）算法的最坏时间复杂度<br>    　若初始文件是反序的，需要进行n-1趟排序。每趟排序要进行n-i次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：<br>        C(max)=n(n-1)/2=O(n^2)<br>        M(max)=3n(n-1)/2=O(n^2)<br>    　冒泡排序的最坏时间复杂度为O(n^2)。</p>\n<p>（3）算法的平均时间复杂度为O(n^2)<br>    　虽然冒泡排序不一定要进行n-1趟，但由于它的记录移动次数较多，故平均时间性能比直接插入排序要差得多。</p>\n<p>（4）算法稳定性<br>    　冒泡排序是就地排序，且它是稳定的。<br>4.优化1（优化外层循环）：<br>    　若在某一趟排序中未发现气泡位置的交换，则说明待排序的无序区中所有气泡均满足轻者在上，重者在下的原则，因此，冒泡排序过程可在此趟排序后终止。为此，在下面给出的算法中，引入一个标签flag，在每趟排序开始前，先将其置为0。若排序过程中发生了交换，则将其置为1。各趟排序结束时检查flag，若未曾发生过交换则终止算法，不再进行下一趟排序。</p>\n<p>具体算法：</p>\n<ol>\n<li>//冒泡排序优化1  </li>\n<li>void BubbleSort2(int[] arr)  </li>\n<li>{  </li>\n<li></li>\n<li>int i = 0, j = 0;<br>int size = arr.length; </li>\n<li></li>\n<li>for (i = 0; i &lt; size - 1; i++)//一共要排序size-1次  </li>\n<li>{  </li>\n<li>//每次遍历标志位都要先置为0，才能判断后面的元素是否发生了交换  </li>\n<li>int flag = 0;  </li>\n<li></li>\n<li>for (j = 0; j &lt; size - 1 - i; j++)//选出该趟排序的最大值往后移动  </li>\n<li>{  </li>\n<li>if (arr[j] &gt; arr[j + 1])  </li>\n<li>{  </li>\n<li>int tmp = arr[j];  </li>\n<li>arr[j] = arr[j + 1];  </li>\n<li>arr[j + 1] = tmp;  </li>\n<li>flag = 1;//只要有发生了交换，flag就置为1  </li>\n<li>}  </li>\n<li>}  </li>\n<li></li>\n<li>//判断标志位是否为0，如果为0，说明后面的元素已经有序，就直接return  </li>\n<li>if (flag == 0)  </li>\n<li>{  </li>\n<li>return;  </li>\n<li>}  </li>\n<li>}  </li>\n<li></li>\n<li>}  </li>\n</ol>\n<p>5、算法优化2（优化内层循环）</p>\n<p>   (1)记住最后一次交换发生位置lastExchange的冒泡排序<br>在每趟扫描中，记住最后一次交换发生的位置lastExchange，（该位置之后的相邻记录均已有序）。下一趟排序开始时，R[1..lastExchange-1]是无序区，R[lastExchange..n]是有序区。这样，一趟排序可能使当前无序区扩充多个记录，因此记住最后一次交换发生的位置lastExchange，从而减少排序的趟数。<br>具体算法：<br>[cpp]<br>view plain<br>copy</p>\n<ol start=\"31\">\n<li>//冒泡排序优化2  </li>\n<li>void BubbleSort3(int[] arr)  </li>\n<li>{  </li>\n<li></li>\n<li>int i = 0, j = 0;</li>\n<li>int size = arr.length;  </li>\n<li>int k = size - 1,pos = 0;//pos变量用来标记循环里最后一次交换的位置    </li>\n<li></li>\n<li>for (i = 0; i &lt; size - 1; i++)//一共要排序size-1次  </li>\n<li>{  </li>\n<li>//每次遍历标志位都要先置为0，才能判断后面的元素是否发生了交换  </li>\n<li>int flag = 0;  </li>\n<li></li>\n<li>for (j = 0; j &lt;k; j++)//选出该趟排序的最大值往后移动  </li>\n<li>{  </li>\n<li>if (arr[j] &gt; arr[j + 1])  </li>\n<li>{  </li>\n<li>int tmp = arr[j];  </li>\n<li>arr[j] = arr[j + 1];  </li>\n<li>arr[j + 1] = tmp;  </li>\n<li>flag = 1;//只要有发生了交换，flag就置为1  </li>\n<li>pos = j;//循环里最后一次交换的位置 j赋给pos  </li>\n<li>}  </li>\n<li>}  </li>\n<li></li>\n<li>k = pos;  </li>\n<li>//判断标志位是否为0，如果为0，说明后面的元素已经有序，就直接return  </li>\n<li>if (flag == 0)  </li>\n<li>{  </li>\n<li>return;  </li>\n<li>}  </li>\n<li>}  </li>\n<li></li>\n<li>}  </li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<pre><code>1.原理：比较两个相邻的元素，将值大的元素交换至右端。\n思路：依次比较相邻的两个数，将小数放在前面，大数放在后面。即在第一趟：首先比较第1个和第2个数，将小数放前，大数放后。然后比较第2个数和第3个数，将小数放前，大数放后，如此继续，直至比较最后两个数，将小数放前，大数放后。重复第一趟步骤，直至全部排序完成。\n举例说明：要排序数组：int[] arr={6,3,8,2,9,1};   \n第一趟排序：\n第一次排序：6和3比较，6大于3，交换位置：  3  6  8  2  9  1\n第二次排序：6和8比较，6小于8，不交换位置：3  6  8  2  9  1\n第三次排序：8和2比较，8大于2，交换位置：  3  6  2  8  9  1\n第四次排序：8和9比较，8小于9，不交换位置：3  6  2  8  9  1\n第五次排序：9和1比较：9大于1，交换位置：  3  6  2  8  1  9\n第一趟总共进行了5次比较， 排序结果：      3  6  2  8  1  9\n---------------------------------------------------------------------\n第二趟排序：\n第一次排序：3和6比较，3小于6，不交换位置：3  6  2  8  1  9\n第二次排序：6和2比较，6大于2，交换位置：  3  2  6  8  1  9\n第三次排序：6和8比较，6大于8，不交换位置：3  2  6  8  1  9\n第四次排序：8和1比较，8大于1，交换位置：  3  2  6  1  8  9\n第二趟总共进行了4次比较， 排序结果：      3  2  6  1  8  9\n---------------------------------------------------------------------\n第三趟排序：\n第一次排序：3和2比较，3大于2，交换位置：  2  3  6  1  8  9\n第二次排序：3和6比较，3小于6，不交换位置：2  3  6  1  8  9\n第三次排序：6和1比较，6大于1，交换位置：  2  3  1  6  8  9\n第二趟总共进行了3次比较， 排序结果：         2  3  1  6  8  9\n---------------------------------------------------------------------\n第四趟排序：\n第一次排序：2和3比较，2小于3，不交换位置：2  3  1  6  8  9\n第二次排序：3和1比较，3大于1，交换位置：  2  1  3  6  8  9\n第二趟总共进行了2次比较， 排序结果：        2  1  3  6  8  9\n---------------------------------------------------------------------\n第五趟排序：\n第一次排序：2和1比较，2大于1，交换位置：  1  2  3  6  8  9\n第二趟总共进行了1次比较， 排序结果：  1  2  3  6  8  9\n---------------------------------------------------------------------\n最终结果：1  2  3  6  8  9\n---------------------------------------------------------------------\n</code></pre><p>2.代码实现<br>    代码实现：<br>    /*</p>\n<pre><code> * 冒泡排序\n */\npublic class BubbleSort {\n　　public static void  BubbleSort1(int[] arr){　　　\n\n        int i = 0, j = 0;\n        Int size=arr.length;\n\n        for (i = 0; i &lt; size - 1; i++)//一共要排序size-1次\n        {\n            for (j = 0; j &lt; size - 1 - i; j++)//选出该趟排序的最大值往后移动\n            {\n                if (arr[j] &gt; arr[j + 1])\n                {\n                    int tmp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = tmp;\n                }\n            }\n        }\n　　}\n }\n</code></pre><p>3、算法分析<br>（1）算法的最好时间复杂度<br>    　若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数C和记录移动次数M均达到最小值：<br>        C(min)=n-1<br>        M(min)=0。<br>    　冒泡排序最好的时间复杂度为O(n)。</p>\n<p>（2）算法的最坏时间复杂度<br>    　若初始文件是反序的，需要进行n-1趟排序。每趟排序要进行n-i次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：<br>        C(max)=n(n-1)/2=O(n^2)<br>        M(max)=3n(n-1)/2=O(n^2)<br>    　冒泡排序的最坏时间复杂度为O(n^2)。</p>\n<p>（3）算法的平均时间复杂度为O(n^2)<br>    　虽然冒泡排序不一定要进行n-1趟，但由于它的记录移动次数较多，故平均时间性能比直接插入排序要差得多。</p>\n<p>（4）算法稳定性<br>    　冒泡排序是就地排序，且它是稳定的。<br>4.优化1（优化外层循环）：<br>    　若在某一趟排序中未发现气泡位置的交换，则说明待排序的无序区中所有气泡均满足轻者在上，重者在下的原则，因此，冒泡排序过程可在此趟排序后终止。为此，在下面给出的算法中，引入一个标签flag，在每趟排序开始前，先将其置为0。若排序过程中发生了交换，则将其置为1。各趟排序结束时检查flag，若未曾发生过交换则终止算法，不再进行下一趟排序。</p>\n<p>具体算法：</p>\n<ol>\n<li>//冒泡排序优化1  </li>\n<li>void BubbleSort2(int[] arr)  </li>\n<li>{  </li>\n<li></li>\n<li>int i = 0, j = 0;<br>int size = arr.length; </li>\n<li></li>\n<li>for (i = 0; i &lt; size - 1; i++)//一共要排序size-1次  </li>\n<li>{  </li>\n<li>//每次遍历标志位都要先置为0，才能判断后面的元素是否发生了交换  </li>\n<li>int flag = 0;  </li>\n<li></li>\n<li>for (j = 0; j &lt; size - 1 - i; j++)//选出该趟排序的最大值往后移动  </li>\n<li>{  </li>\n<li>if (arr[j] &gt; arr[j + 1])  </li>\n<li>{  </li>\n<li>int tmp = arr[j];  </li>\n<li>arr[j] = arr[j + 1];  </li>\n<li>arr[j + 1] = tmp;  </li>\n<li>flag = 1;//只要有发生了交换，flag就置为1  </li>\n<li>}  </li>\n<li>}  </li>\n<li></li>\n<li>//判断标志位是否为0，如果为0，说明后面的元素已经有序，就直接return  </li>\n<li>if (flag == 0)  </li>\n<li>{  </li>\n<li>return;  </li>\n<li>}  </li>\n<li>}  </li>\n<li></li>\n<li>}  </li>\n</ol>\n<p>5、算法优化2（优化内层循环）</p>\n<p>   (1)记住最后一次交换发生位置lastExchange的冒泡排序<br>在每趟扫描中，记住最后一次交换发生的位置lastExchange，（该位置之后的相邻记录均已有序）。下一趟排序开始时，R[1..lastExchange-1]是无序区，R[lastExchange..n]是有序区。这样，一趟排序可能使当前无序区扩充多个记录，因此记住最后一次交换发生的位置lastExchange，从而减少排序的趟数。<br>具体算法：<br>[cpp]<br>view plain<br>copy</p>\n<ol start=\"31\">\n<li>//冒泡排序优化2  </li>\n<li>void BubbleSort3(int[] arr)  </li>\n<li>{  </li>\n<li></li>\n<li>int i = 0, j = 0;</li>\n<li>int size = arr.length;  </li>\n<li>int k = size - 1,pos = 0;//pos变量用来标记循环里最后一次交换的位置    </li>\n<li></li>\n<li>for (i = 0; i &lt; size - 1; i++)//一共要排序size-1次  </li>\n<li>{  </li>\n<li>//每次遍历标志位都要先置为0，才能判断后面的元素是否发生了交换  </li>\n<li>int flag = 0;  </li>\n<li></li>\n<li>for (j = 0; j &lt;k; j++)//选出该趟排序的最大值往后移动  </li>\n<li>{  </li>\n<li>if (arr[j] &gt; arr[j + 1])  </li>\n<li>{  </li>\n<li>int tmp = arr[j];  </li>\n<li>arr[j] = arr[j + 1];  </li>\n<li>arr[j + 1] = tmp;  </li>\n<li>flag = 1;//只要有发生了交换，flag就置为1  </li>\n<li>pos = j;//循环里最后一次交换的位置 j赋给pos  </li>\n<li>}  </li>\n<li>}  </li>\n<li></li>\n<li>k = pos;  </li>\n<li>//判断标志位是否为0，如果为0，说明后面的元素已经有序，就直接return  </li>\n<li>if (flag == 0)  </li>\n<li>{  </li>\n<li>return;  </li>\n<li>}  </li>\n<li>}  </li>\n<li></li>\n<li>}  </li>\n</ol>\n"},{"title":"基数排序","date":"2018-04-16T15:20:40.000Z","_content":"基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机上的贡献。它是这样实现的：将所有待比较正整数统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始进行基数为10的计数排序，一直到最高位计数排序完后，数列就变成一个有序序列（利用了计数排序的稳定性）。\n基数排序的实现代码如下：\n\n#include<iostream>\nusing namespace std;\n// 分类 ------------- 内部非比较排序\n// 数据结构 ---------- 数组\n// 最差时间复杂度 ---- O(n * dn)\n// 最优时间复杂度 ---- O(n * dn)\n// 平均时间复杂度 ---- O(n * dn)\n// 所需辅助空间 ------ O(n * dn)\n// 稳定性 ----------- 稳定\nconst int dn = 3;                // 待排序的元素为三位数及以下\nconst int k = 10;                // 基数为10，每一位的数字都是[0,9]内的整数\nint C[k];\nint GetDigit(int x, int d)          // 获得元素x的第d位数字\n{\n    int radix[] = { 1, 1, 10, 100 };// 最大为三位数，所以这里只要到百位就满足了\n    return (x / radix[d]) % 10;\n}\nvoid CountingSort(int A[], int n, int d)// 依据元素的第d位数字，对A数组进行计数排序\n{\n    for (int i = 0; i < k; i++)\n    {\n        C[i] = 0;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        C[GetDigit(A[i], d)]++;\n    }\n    for (int i = 1; i < k; i++)\n    {\n        C[i] = C[i] + C[i - 1];\n    }\n    int *B = (int*)malloc(n * sizeof(int));\n    for (int i = n - 1; i >= 0; i--)\n    {\n        int dight = GetDigit(A[i], d);  // 元素A[i]当前位数字为dight   \n        B[--C[dight]] = A[i];           // 根据当前位数字，把每个元素A[i]放到它在输出数组B中的正确位置上\n        // 当再遇到当前位数字同为dight的元素时，会将其放在当前元素的前一个位置上保证计数排序的稳定性\n    }\n    for (int i = 0; i < n; i++)\n    {\n        A[i] = B[i];\n    }\n    free(B);\n}\nvoid LsdRadixSort(int A[], int n)     // 最低位优先基数排序\n{\n    for (int d = 1; d <= dn; d++)     // 从低位到高位\n        CountingSort(A, n, d);        // 依据第d位数字对A进行计数排序\n}\nint main()\n{\n    int A[] = { 20, 90, 64, 289, 998, 365, 852, 123, 789, 456 };// 针对基数排序设计的输入\n    int n = sizeof(A) / sizeof(int);\n    LsdRadixSort(A, n);\n    printf(\"基数排序结果：\");\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \", A[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \n下图给出了对{ 329, 457, 657, 839, 436, 720, 355 }进行基数排序的简单演示过程\n![图片](\\基数排序\\jishu.jpg)\n\n基数排序的时间复杂度是O(n * dn)，其中n是待排序元素个数，dn是数字位数。这个时间复杂度不一定优于O(n log n)，dn的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；dn决定了进行多少轮处理，而n是每轮处理的操作数目。\n如果考虑和比较排序进行对照，基数排序的形式复杂度虽然不一定更小，但由于不进行比较，因此其基本操作的代价较小，而且如果适当的选择基数，dn一般不大于log n，所以基数排序一般要快过基于比较的排序，比如快速排序。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序并不是只能用于整数排序。\n\n\n","source":"_posts/基数排序.md","raw":"---\ntitle: 基数排序\ntags: \n- 算法排序\n- 基础知识\ncategories: \n- 基础知识\n- 算法排序\ndate: 2018-04-16 23:20:40\n---\n基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机上的贡献。它是这样实现的：将所有待比较正整数统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始进行基数为10的计数排序，一直到最高位计数排序完后，数列就变成一个有序序列（利用了计数排序的稳定性）。\n基数排序的实现代码如下：\n\n#include<iostream>\nusing namespace std;\n// 分类 ------------- 内部非比较排序\n// 数据结构 ---------- 数组\n// 最差时间复杂度 ---- O(n * dn)\n// 最优时间复杂度 ---- O(n * dn)\n// 平均时间复杂度 ---- O(n * dn)\n// 所需辅助空间 ------ O(n * dn)\n// 稳定性 ----------- 稳定\nconst int dn = 3;                // 待排序的元素为三位数及以下\nconst int k = 10;                // 基数为10，每一位的数字都是[0,9]内的整数\nint C[k];\nint GetDigit(int x, int d)          // 获得元素x的第d位数字\n{\n    int radix[] = { 1, 1, 10, 100 };// 最大为三位数，所以这里只要到百位就满足了\n    return (x / radix[d]) % 10;\n}\nvoid CountingSort(int A[], int n, int d)// 依据元素的第d位数字，对A数组进行计数排序\n{\n    for (int i = 0; i < k; i++)\n    {\n        C[i] = 0;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        C[GetDigit(A[i], d)]++;\n    }\n    for (int i = 1; i < k; i++)\n    {\n        C[i] = C[i] + C[i - 1];\n    }\n    int *B = (int*)malloc(n * sizeof(int));\n    for (int i = n - 1; i >= 0; i--)\n    {\n        int dight = GetDigit(A[i], d);  // 元素A[i]当前位数字为dight   \n        B[--C[dight]] = A[i];           // 根据当前位数字，把每个元素A[i]放到它在输出数组B中的正确位置上\n        // 当再遇到当前位数字同为dight的元素时，会将其放在当前元素的前一个位置上保证计数排序的稳定性\n    }\n    for (int i = 0; i < n; i++)\n    {\n        A[i] = B[i];\n    }\n    free(B);\n}\nvoid LsdRadixSort(int A[], int n)     // 最低位优先基数排序\n{\n    for (int d = 1; d <= dn; d++)     // 从低位到高位\n        CountingSort(A, n, d);        // 依据第d位数字对A进行计数排序\n}\nint main()\n{\n    int A[] = { 20, 90, 64, 289, 998, 365, 852, 123, 789, 456 };// 针对基数排序设计的输入\n    int n = sizeof(A) / sizeof(int);\n    LsdRadixSort(A, n);\n    printf(\"基数排序结果：\");\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \", A[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \n下图给出了对{ 329, 457, 657, 839, 436, 720, 355 }进行基数排序的简单演示过程\n![图片](\\基数排序\\jishu.jpg)\n\n基数排序的时间复杂度是O(n * dn)，其中n是待排序元素个数，dn是数字位数。这个时间复杂度不一定优于O(n log n)，dn的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；dn决定了进行多少轮处理，而n是每轮处理的操作数目。\n如果考虑和比较排序进行对照，基数排序的形式复杂度虽然不一定更小，但由于不进行比较，因此其基本操作的代价较小，而且如果适当的选择基数，dn一般不大于log n，所以基数排序一般要快过基于比较的排序，比如快速排序。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序并不是只能用于整数排序。\n\n\n","slug":"基数排序","published":1,"updated":"2018-04-29T06:42:47.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgkim7zg0009iku7tzxmhv3s","content":"<p>基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机上的贡献。它是这样实现的：将所有待比较正整数统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始进行基数为10的计数排序，一直到最高位计数排序完后，数列就变成一个有序序列（利用了计数排序的稳定性）。<br>基数排序的实现代码如下：</p>\n<p>#include<iostream><br>using namespace std;<br>// 分类 ————- 内部非比较排序<br>// 数据结构 ———- 数组<br>// 最差时间复杂度 —- O(n <em> dn)<br>// 最优时间复杂度 —- O(n </em> dn)<br>// 平均时间复杂度 —- O(n <em> dn)<br>// 所需辅助空间 —— O(n </em> dn)<br>// 稳定性 ———– 稳定<br>const int dn = 3;                // 待排序的元素为三位数及以下<br>const int k = 10;                // 基数为10，每一位的数字都是[0,9]内的整数<br>int C[k];<br>int GetDigit(int x, int d)          // 获得元素x的第d位数字<br>{<br>    int radix[] = { 1, 1, 10, 100 };// 最大为三位数，所以这里只要到百位就满足了<br>    return (x / radix[d]) % 10;<br>}<br>void CountingSort(int A[], int n, int d)// 依据元素的第d位数字，对A数组进行计数排序<br>{<br>    for (int i = 0; i &lt; k; i++)<br>    {<br>        C[i] = 0;<br>    }<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        C[GetDigit(A[i], d)]++;<br>    }<br>    for (int i = 1; i &lt; k; i++)<br>    {<br>        C[i] = C[i] + C[i - 1];<br>    }<br>    int <em>B = (int</em>)malloc(n * sizeof(int));<br>    for (int i = n - 1; i &gt;= 0; i–)<br>    {<br>        int dight = GetDigit(A[i], d);  // 元素A[i]当前位数字为dight<br>        B[–C[dight]] = A[i];           // 根据当前位数字，把每个元素A[i]放到它在输出数组B中的正确位置上<br>        // 当再遇到当前位数字同为dight的元素时，会将其放在当前元素的前一个位置上保证计数排序的稳定性<br>    }<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        A[i] = B[i];<br>    }<br>    free(B);<br>}<br>void LsdRadixSort(int A[], int n)     // 最低位优先基数排序<br>{<br>    for (int d = 1; d &lt;= dn; d++)     // 从低位到高位<br>        CountingSort(A, n, d);        // 依据第d位数字对A进行计数排序<br>}<br>int main()<br>{<br>    int A[] = { 20, 90, 64, 289, 998, 365, 852, 123, 789, 456 };// 针对基数排序设计的输入<br>    int n = sizeof(A) / sizeof(int);<br>    LsdRadixSort(A, n);<br>    printf(“基数排序结果：”);<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        printf(“%d “, A[i]);<br>    }<br>    printf(“\\n”);<br>    return 0;<br>}</iostream></p>\n<p>下图给出了对{ 329, 457, 657, 839, 436, 720, 355 }进行基数排序的简单演示过程<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"\\基数排序\\jishu.jpg\" alt=\"图片\" title=\"\">\n                </div>\n                <div class=\"image-caption\">图片</div>\n            </figure></p>\n<p>基数排序的时间复杂度是O(n * dn)，其中n是待排序元素个数，dn是数字位数。这个时间复杂度不一定优于O(n log n)，dn的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；dn决定了进行多少轮处理，而n是每轮处理的操作数目。<br>如果考虑和比较排序进行对照，基数排序的形式复杂度虽然不一定更小，但由于不进行比较，因此其基本操作的代价较小，而且如果适当的选择基数，dn一般不大于log n，所以基数排序一般要快过基于比较的排序，比如快速排序。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序并不是只能用于整数排序。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机上的贡献。它是这样实现的：将所有待比较正整数统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始进行基数为10的计数排序，一直到最高位计数排序完后，数列就变成一个有序序列（利用了计数排序的稳定性）。<br>基数排序的实现代码如下：</p>\n<p>#include<iostream><br>using namespace std;<br>// 分类 ————- 内部非比较排序<br>// 数据结构 ———- 数组<br>// 最差时间复杂度 —- O(n <em> dn)<br>// 最优时间复杂度 —- O(n </em> dn)<br>// 平均时间复杂度 —- O(n <em> dn)<br>// 所需辅助空间 —— O(n </em> dn)<br>// 稳定性 ———– 稳定<br>const int dn = 3;                // 待排序的元素为三位数及以下<br>const int k = 10;                // 基数为10，每一位的数字都是[0,9]内的整数<br>int C[k];<br>int GetDigit(int x, int d)          // 获得元素x的第d位数字<br>{<br>    int radix[] = { 1, 1, 10, 100 };// 最大为三位数，所以这里只要到百位就满足了<br>    return (x / radix[d]) % 10;<br>}<br>void CountingSort(int A[], int n, int d)// 依据元素的第d位数字，对A数组进行计数排序<br>{<br>    for (int i = 0; i &lt; k; i++)<br>    {<br>        C[i] = 0;<br>    }<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        C[GetDigit(A[i], d)]++;<br>    }<br>    for (int i = 1; i &lt; k; i++)<br>    {<br>        C[i] = C[i] + C[i - 1];<br>    }<br>    int <em>B = (int</em>)malloc(n * sizeof(int));<br>    for (int i = n - 1; i &gt;= 0; i–)<br>    {<br>        int dight = GetDigit(A[i], d);  // 元素A[i]当前位数字为dight<br>        B[–C[dight]] = A[i];           // 根据当前位数字，把每个元素A[i]放到它在输出数组B中的正确位置上<br>        // 当再遇到当前位数字同为dight的元素时，会将其放在当前元素的前一个位置上保证计数排序的稳定性<br>    }<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        A[i] = B[i];<br>    }<br>    free(B);<br>}<br>void LsdRadixSort(int A[], int n)     // 最低位优先基数排序<br>{<br>    for (int d = 1; d &lt;= dn; d++)     // 从低位到高位<br>        CountingSort(A, n, d);        // 依据第d位数字对A进行计数排序<br>}<br>int main()<br>{<br>    int A[] = { 20, 90, 64, 289, 998, 365, 852, 123, 789, 456 };// 针对基数排序设计的输入<br>    int n = sizeof(A) / sizeof(int);<br>    LsdRadixSort(A, n);<br>    printf(“基数排序结果：”);<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        printf(“%d “, A[i]);<br>    }<br>    printf(“\\n”);<br>    return 0;<br>}</iostream></p>\n<p>下图给出了对{ 329, 457, 657, 839, 436, 720, 355 }进行基数排序的简单演示过程<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"\\基数排序\\jishu.jpg\" alt=\"图片\" title=\"\">\n                </div>\n                <div class=\"image-caption\">图片</div>\n            </figure></p>\n<p>基数排序的时间复杂度是O(n * dn)，其中n是待排序元素个数，dn是数字位数。这个时间复杂度不一定优于O(n log n)，dn的大小取决于数字位的选择（比如比特位数），和待排序数据所属数据类型的全集的大小；dn决定了进行多少轮处理，而n是每轮处理的操作数目。<br>如果考虑和比较排序进行对照，基数排序的形式复杂度虽然不一定更小，但由于不进行比较，因此其基本操作的代价较小，而且如果适当的选择基数，dn一般不大于log n，所以基数排序一般要快过基于比较的排序，比如快速排序。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序并不是只能用于整数排序。</p>\n"},{"title":"堆排序","date":"2018-04-16T15:20:40.000Z","_content":"一、基础知识\n我们通常所说的堆是指二叉堆，二叉堆又称完全二叉树或者叫近似完全二叉树。二叉堆又分为最大堆和最小堆。\n堆排序(Heapsort)是指利用堆这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。数组可以根据索引直接获取元素，时间复杂度为O（1），也就是常量，因此对于取值效率极高。\n最大堆的特性如下：\n\n父结点的键值总是大于或者等于任何一个子节点的键值\n每个结点的左子树和右子树都是一个最大堆\n最小堆的特性如下：\n\n父结点的键值总是小于或者等于任何一个子节点的键值\n每个结点的左子树和右子树都是一个最小堆\n二、算法思想\n1.最大堆的算法思想是：\n先将初始的R[0…n-1]建立成最大堆，此时是无序堆，而堆顶是最大元素\n再将堆顶R[0]和无序区的最后一个记录R[n-1]交换，由此得到新的无序区R[0…n-2]和有序区R[n-1]，且满足R[0…n-2].keys ≤ R[n-1].key\n由于交换后，前R[0…n-2]可能不满足最大堆的性质，因此再调整前R[0…n-2]为最大堆，直到只有R[0]最后一个元素才调整完成。\n最大堆排序完成后，其实是升序序列，每次调整堆都是要得到最大的一个元素，然后与当前堆的最后一个元素交换，因此最后所得到的序列是升序序列。\n2.最小堆的算法思想是：\n先将初始的R[0…n-1]建立成最小堆，此时是无序堆，而堆顶元素是最小的元素\n再将堆顶R[0]与无序区的最后一个R[n-1]交换，由此得到新的无序堆R[0…n-2]和有序堆R[n-1]，且满足R[0…n-2].keys >= R[n-1].key\n由于交换后，前R[0…n-2]可能不满足最小堆的性质，因此再调整前R[0…n-2]为最小堆，直到只有R[0]最后一个元素才调整完成\n最小堆排序完成后，其实是降序序列，每次调整堆都是要得到最小的一个元素，然后与当前无序堆的最后一个元素交换，所以所得到的序列是降序的。\n提示：堆排序的过程，其实就是不断地扩大有序区，然后不断地缩小无序区，直到只有有序区的过程。\n\n三、排序过程分析\n因为算法比较抽象，这里直接通过举个小例子来说明堆排序的过程是如何的。下面我们用这个无序序列采用最大堆的进行堆排序，所得到的序列就是升序序列（ASC）。\n无序序列：89,-7,999,-89,7,0,-888,7,-7\n第一步：初始化建成最大堆：\n![图片](\\堆排序\\dui1.png)\n\n第二步：将堆顶最大元素999与无序区的最后一个元素交换，使999成为有序区。交换后，-7成为堆顶，由于-7并不是无序区中最大的元素，因此需要调整无序区，使无序区中最大值89成为堆顶，所以-7与89交换。交换后导致89的右子树不满足最大堆的性质，因此要对右子树调整成最大堆，所以-7要与0交换，如下图：\n![图片](\\堆排序\\dui2.jpg)\n\n从图中看到，当-7成89交换后，堆顶是最大元素了，但是-7的左孩子是0，右孩子是-888，由于-7<0，导致-7这个结点不满足堆的性质，因此需要调整它。所以，0与-7交换。\n然后不断重复着第二步的过程，直到全部成为有序区。\n最后：所得到的是升序序列\n\n![图片](\\堆排序\\dui3.jpg)\n\n四、时间复杂度\n堆排序的时间，主要由建立初始堆和反复调整堆这两部分的时间开销构成.由于堆排序是不稳定的，它得扭到的时间复杂度会根据实际情况较大，因此只能取平均时间复杂度。\n平均时间复杂度为：O( N * log2(N) )\n堆排序耗时的操作有：初始堆 + 反复调整堆，时间复杂度如下：\n1.初始建堆：每个父节点会和左右子节点进行最多2次比较和1次交换，所以复杂度跟父节点个数有关。根据2x <= n（x为n个元素可以折半的次数，也就是父节点个数），得出x = log2n。即O ( log2n )\n2.反复调整堆：由于初始化堆过程中，会记录数组比较结果，所以堆排序对原序列的数组顺序并不敏感，最好情况和最坏情况差不多。需要抽取 n-1 次堆顶元素，每次取堆顶元素都需要重建堆（O(重建堆) < O(初始堆)）。所以小于 O(n-1) * O(log2n)\n使用建议：\n由于初始化堆需要比较的次数较多，因此，堆排序比较适合于数据量非常大的场合（百万数据或更多）。由于高效的快速排序是基于递归实现的，所以在数据量非常大时会发生堆栈溢出错误。\n\n五、Java示例代码\n\npublic class HeapSort{\n private static int[] sort=new int[]{1,0,10,20,3,5,6,4,9,8,12,\n   17,34,11};\n \n public static void main(String[] args){\n  buildMaxHeapify(sort);\n  heapSort(sort);\n  print(sort);\n }\n \n private static void buildMaxHeapify(int[] data){\n//没有子节点的才需要创建最大堆，从最后一个的父节点开始\n  int startIndex=getParentIndex(data.length-1);\n//从尾端开始创建最大堆，每次都是正确的堆\n  for(int i=startIndex;i>=0;i--){\n   maxHeapify(data,data.length,i);\n  }\n }\n \n /**\n  *创建最大堆\n  *\n  *@paramdata\n  *@paramheapSize需要创建最大堆的大小，一般在sort的时候用到，因为最多值放在末尾，末尾就不再归入最大堆了\n  *@paramindex当前需要创建最大堆的位置\n  */\n private static void maxHeapify(int[] data,int heapSize,int index){\n//当前点与左右子节点比较\n  int left=getChildLeftIndex(index);\n  int right=getChildRightIndex(index);\n \n  int largest=index;\n  if(left<heapSize&&data[index]<data[left]){\n   largest=left;\n  }\n  if(right<heapSize&&data[largest]<data[right]){\n   largest=right;\n  }\n//得到最大值后可能需要交换，如果交换了，其子节点可能就不是最大堆了，需要重新调整\n  if(largest!=index){\n   int temp=data[index];\n   data[index]=data[largest];\n   data[largest]=temp;\n   maxHeapify(data,heapSize,largest);\n  }\n }\n \n /**\n  *排序，最大值放在末尾，data虽然是最大堆，在排序后就成了递增的\n  *\n  *@paramdata\n  */\n private static void heapSort(int[] data){\n//末尾与头交换，交换后调整最大堆\n  for(int i=data.length-1;i>0;i--){\n   int temp=data[0];\n   data[0]=data[i];\n   data[i]=temp;\n   maxHeapify(data,i,0);\n  }\n }\n \n /**\n  *父节点位置\n  *\n  *@paramcurrent\n  *@return\n  */\n private static int getParentIndex(int current){\n  return(current-1)>>1;\n }\n \n /**\n  *左子节点position注意括号，加法优先级更高\n  *\n  *@paramcurrent\n  *@return\n  */\n private static int getChildLeftIndex(int current){\n  return(current<<1)+1;\n }\n \n /**\n  *右子节点position\n  *\n  *@paramcurrent\n  *@return\n  */\n private static int getChildRightIndex(int current){\n  return(current<<1)+2;\n }\n \n private static void print(int[] data){\n  int pre=-2;\n  for(int i=0;i<data.length;i++){\n   if(pre<(int)getLog(i+1)){\n    pre=(int)getLog(i+1);\n    System.out.println();\n   }\n   System.out.print(data[i]+\"|\");\n  }\n }\n \n /**\n  *以2为底的对数\n  *\n  *@paramparam\n  *@return\n  */\n private static double getLog(double param){\n  return Math.log(param)/Math.log(2);\n }\n}\n\n","source":"_posts/堆排序.md","raw":"---\ntitle: 堆排序\ntags: \n- 算法排序\n- 基础知识\ncategories: \n- 基础知识\n- 算法排序\ndate: 2018-04-16 23:20:40\n---\n一、基础知识\n我们通常所说的堆是指二叉堆，二叉堆又称完全二叉树或者叫近似完全二叉树。二叉堆又分为最大堆和最小堆。\n堆排序(Heapsort)是指利用堆这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。数组可以根据索引直接获取元素，时间复杂度为O（1），也就是常量，因此对于取值效率极高。\n最大堆的特性如下：\n\n父结点的键值总是大于或者等于任何一个子节点的键值\n每个结点的左子树和右子树都是一个最大堆\n最小堆的特性如下：\n\n父结点的键值总是小于或者等于任何一个子节点的键值\n每个结点的左子树和右子树都是一个最小堆\n二、算法思想\n1.最大堆的算法思想是：\n先将初始的R[0…n-1]建立成最大堆，此时是无序堆，而堆顶是最大元素\n再将堆顶R[0]和无序区的最后一个记录R[n-1]交换，由此得到新的无序区R[0…n-2]和有序区R[n-1]，且满足R[0…n-2].keys ≤ R[n-1].key\n由于交换后，前R[0…n-2]可能不满足最大堆的性质，因此再调整前R[0…n-2]为最大堆，直到只有R[0]最后一个元素才调整完成。\n最大堆排序完成后，其实是升序序列，每次调整堆都是要得到最大的一个元素，然后与当前堆的最后一个元素交换，因此最后所得到的序列是升序序列。\n2.最小堆的算法思想是：\n先将初始的R[0…n-1]建立成最小堆，此时是无序堆，而堆顶元素是最小的元素\n再将堆顶R[0]与无序区的最后一个R[n-1]交换，由此得到新的无序堆R[0…n-2]和有序堆R[n-1]，且满足R[0…n-2].keys >= R[n-1].key\n由于交换后，前R[0…n-2]可能不满足最小堆的性质，因此再调整前R[0…n-2]为最小堆，直到只有R[0]最后一个元素才调整完成\n最小堆排序完成后，其实是降序序列，每次调整堆都是要得到最小的一个元素，然后与当前无序堆的最后一个元素交换，所以所得到的序列是降序的。\n提示：堆排序的过程，其实就是不断地扩大有序区，然后不断地缩小无序区，直到只有有序区的过程。\n\n三、排序过程分析\n因为算法比较抽象，这里直接通过举个小例子来说明堆排序的过程是如何的。下面我们用这个无序序列采用最大堆的进行堆排序，所得到的序列就是升序序列（ASC）。\n无序序列：89,-7,999,-89,7,0,-888,7,-7\n第一步：初始化建成最大堆：\n![图片](\\堆排序\\dui1.png)\n\n第二步：将堆顶最大元素999与无序区的最后一个元素交换，使999成为有序区。交换后，-7成为堆顶，由于-7并不是无序区中最大的元素，因此需要调整无序区，使无序区中最大值89成为堆顶，所以-7与89交换。交换后导致89的右子树不满足最大堆的性质，因此要对右子树调整成最大堆，所以-7要与0交换，如下图：\n![图片](\\堆排序\\dui2.jpg)\n\n从图中看到，当-7成89交换后，堆顶是最大元素了，但是-7的左孩子是0，右孩子是-888，由于-7<0，导致-7这个结点不满足堆的性质，因此需要调整它。所以，0与-7交换。\n然后不断重复着第二步的过程，直到全部成为有序区。\n最后：所得到的是升序序列\n\n![图片](\\堆排序\\dui3.jpg)\n\n四、时间复杂度\n堆排序的时间，主要由建立初始堆和反复调整堆这两部分的时间开销构成.由于堆排序是不稳定的，它得扭到的时间复杂度会根据实际情况较大，因此只能取平均时间复杂度。\n平均时间复杂度为：O( N * log2(N) )\n堆排序耗时的操作有：初始堆 + 反复调整堆，时间复杂度如下：\n1.初始建堆：每个父节点会和左右子节点进行最多2次比较和1次交换，所以复杂度跟父节点个数有关。根据2x <= n（x为n个元素可以折半的次数，也就是父节点个数），得出x = log2n。即O ( log2n )\n2.反复调整堆：由于初始化堆过程中，会记录数组比较结果，所以堆排序对原序列的数组顺序并不敏感，最好情况和最坏情况差不多。需要抽取 n-1 次堆顶元素，每次取堆顶元素都需要重建堆（O(重建堆) < O(初始堆)）。所以小于 O(n-1) * O(log2n)\n使用建议：\n由于初始化堆需要比较的次数较多，因此，堆排序比较适合于数据量非常大的场合（百万数据或更多）。由于高效的快速排序是基于递归实现的，所以在数据量非常大时会发生堆栈溢出错误。\n\n五、Java示例代码\n\npublic class HeapSort{\n private static int[] sort=new int[]{1,0,10,20,3,5,6,4,9,8,12,\n   17,34,11};\n \n public static void main(String[] args){\n  buildMaxHeapify(sort);\n  heapSort(sort);\n  print(sort);\n }\n \n private static void buildMaxHeapify(int[] data){\n//没有子节点的才需要创建最大堆，从最后一个的父节点开始\n  int startIndex=getParentIndex(data.length-1);\n//从尾端开始创建最大堆，每次都是正确的堆\n  for(int i=startIndex;i>=0;i--){\n   maxHeapify(data,data.length,i);\n  }\n }\n \n /**\n  *创建最大堆\n  *\n  *@paramdata\n  *@paramheapSize需要创建最大堆的大小，一般在sort的时候用到，因为最多值放在末尾，末尾就不再归入最大堆了\n  *@paramindex当前需要创建最大堆的位置\n  */\n private static void maxHeapify(int[] data,int heapSize,int index){\n//当前点与左右子节点比较\n  int left=getChildLeftIndex(index);\n  int right=getChildRightIndex(index);\n \n  int largest=index;\n  if(left<heapSize&&data[index]<data[left]){\n   largest=left;\n  }\n  if(right<heapSize&&data[largest]<data[right]){\n   largest=right;\n  }\n//得到最大值后可能需要交换，如果交换了，其子节点可能就不是最大堆了，需要重新调整\n  if(largest!=index){\n   int temp=data[index];\n   data[index]=data[largest];\n   data[largest]=temp;\n   maxHeapify(data,heapSize,largest);\n  }\n }\n \n /**\n  *排序，最大值放在末尾，data虽然是最大堆，在排序后就成了递增的\n  *\n  *@paramdata\n  */\n private static void heapSort(int[] data){\n//末尾与头交换，交换后调整最大堆\n  for(int i=data.length-1;i>0;i--){\n   int temp=data[0];\n   data[0]=data[i];\n   data[i]=temp;\n   maxHeapify(data,i,0);\n  }\n }\n \n /**\n  *父节点位置\n  *\n  *@paramcurrent\n  *@return\n  */\n private static int getParentIndex(int current){\n  return(current-1)>>1;\n }\n \n /**\n  *左子节点position注意括号，加法优先级更高\n  *\n  *@paramcurrent\n  *@return\n  */\n private static int getChildLeftIndex(int current){\n  return(current<<1)+1;\n }\n \n /**\n  *右子节点position\n  *\n  *@paramcurrent\n  *@return\n  */\n private static int getChildRightIndex(int current){\n  return(current<<1)+2;\n }\n \n private static void print(int[] data){\n  int pre=-2;\n  for(int i=0;i<data.length;i++){\n   if(pre<(int)getLog(i+1)){\n    pre=(int)getLog(i+1);\n    System.out.println();\n   }\n   System.out.print(data[i]+\"|\");\n  }\n }\n \n /**\n  *以2为底的对数\n  *\n  *@paramparam\n  *@return\n  */\n private static double getLog(double param){\n  return Math.log(param)/Math.log(2);\n }\n}\n\n","slug":"堆排序","published":1,"updated":"2018-04-29T06:42:47.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgkim7zi000aiku71ebel28c","content":"<p>一、基础知识<br>我们通常所说的堆是指二叉堆，二叉堆又称完全二叉树或者叫近似完全二叉树。二叉堆又分为最大堆和最小堆。<br>堆排序(Heapsort)是指利用堆这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。数组可以根据索引直接获取元素，时间复杂度为O（1），也就是常量，因此对于取值效率极高。<br>最大堆的特性如下：</p>\n<p>父结点的键值总是大于或者等于任何一个子节点的键值<br>每个结点的左子树和右子树都是一个最大堆<br>最小堆的特性如下：</p>\n<p>父结点的键值总是小于或者等于任何一个子节点的键值<br>每个结点的左子树和右子树都是一个最小堆<br>二、算法思想<br>1.最大堆的算法思想是：<br>先将初始的R[0…n-1]建立成最大堆，此时是无序堆，而堆顶是最大元素<br>再将堆顶R[0]和无序区的最后一个记录R[n-1]交换，由此得到新的无序区R[0…n-2]和有序区R[n-1]，且满足R[0…n-2].keys ≤ R[n-1].key<br>由于交换后，前R[0…n-2]可能不满足最大堆的性质，因此再调整前R[0…n-2]为最大堆，直到只有R[0]最后一个元素才调整完成。<br>最大堆排序完成后，其实是升序序列，每次调整堆都是要得到最大的一个元素，然后与当前堆的最后一个元素交换，因此最后所得到的序列是升序序列。<br>2.最小堆的算法思想是：<br>先将初始的R[0…n-1]建立成最小堆，此时是无序堆，而堆顶元素是最小的元素<br>再将堆顶R[0]与无序区的最后一个R[n-1]交换，由此得到新的无序堆R[0…n-2]和有序堆R[n-1]，且满足R[0…n-2].keys &gt;= R[n-1].key<br>由于交换后，前R[0…n-2]可能不满足最小堆的性质，因此再调整前R[0…n-2]为最小堆，直到只有R[0]最后一个元素才调整完成<br>最小堆排序完成后，其实是降序序列，每次调整堆都是要得到最小的一个元素，然后与当前无序堆的最后一个元素交换，所以所得到的序列是降序的。<br>提示：堆排序的过程，其实就是不断地扩大有序区，然后不断地缩小无序区，直到只有有序区的过程。</p>\n<p>三、排序过程分析<br>因为算法比较抽象，这里直接通过举个小例子来说明堆排序的过程是如何的。下面我们用这个无序序列采用最大堆的进行堆排序，所得到的序列就是升序序列（ASC）。<br>无序序列：89,-7,999,-89,7,0,-888,7,-7<br>第一步：初始化建成最大堆：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"\\堆排序\\dui1.png\" alt=\"图片\" title=\"\">\n                </div>\n                <div class=\"image-caption\">图片</div>\n            </figure></p>\n<p>第二步：将堆顶最大元素999与无序区的最后一个元素交换，使999成为有序区。交换后，-7成为堆顶，由于-7并不是无序区中最大的元素，因此需要调整无序区，使无序区中最大值89成为堆顶，所以-7与89交换。交换后导致89的右子树不满足最大堆的性质，因此要对右子树调整成最大堆，所以-7要与0交换，如下图：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"\\堆排序\\dui2.jpg\" alt=\"图片\" title=\"\">\n                </div>\n                <div class=\"image-caption\">图片</div>\n            </figure></p>\n<p>从图中看到，当-7成89交换后，堆顶是最大元素了，但是-7的左孩子是0，右孩子是-888，由于-7&lt;0，导致-7这个结点不满足堆的性质，因此需要调整它。所以，0与-7交换。<br>然后不断重复着第二步的过程，直到全部成为有序区。<br>最后：所得到的是升序序列</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"\\堆排序\\dui3.jpg\" alt=\"图片\" title=\"\">\n                </div>\n                <div class=\"image-caption\">图片</div>\n            </figure>\n<p>四、时间复杂度<br>堆排序的时间，主要由建立初始堆和反复调整堆这两部分的时间开销构成.由于堆排序是不稳定的，它得扭到的时间复杂度会根据实际情况较大，因此只能取平均时间复杂度。<br>平均时间复杂度为：O( N <em> log2(N) )<br>堆排序耗时的操作有：初始堆 + 反复调整堆，时间复杂度如下：<br>1.初始建堆：每个父节点会和左右子节点进行最多2次比较和1次交换，所以复杂度跟父节点个数有关。根据2x &lt;= n（x为n个元素可以折半的次数，也就是父节点个数），得出x = log2n。即O ( log2n )<br>2.反复调整堆：由于初始化堆过程中，会记录数组比较结果，所以堆排序对原序列的数组顺序并不敏感，最好情况和最坏情况差不多。需要抽取 n-1 次堆顶元素，每次取堆顶元素都需要重建堆（O(重建堆) &lt; O(初始堆)）。所以小于 O(n-1) </em> O(log2n)<br>使用建议：<br>由于初始化堆需要比较的次数较多，因此，堆排序比较适合于数据量非常大的场合（百万数据或更多）。由于高效的快速排序是基于递归实现的，所以在数据量非常大时会发生堆栈溢出错误。</p>\n<p>五、Java示例代码</p>\n<p>public class HeapSort{<br> private static int[] sort=new int[]{1,0,10,20,3,5,6,4,9,8,12,<br>   17,34,11};</p>\n<p> public static void main(String[] args){<br>  buildMaxHeapify(sort);<br>  heapSort(sort);<br>  print(sort);<br> }</p>\n<p> private static void buildMaxHeapify(int[] data){<br>//没有子节点的才需要创建最大堆，从最后一个的父节点开始<br>  int startIndex=getParentIndex(data.length-1);<br>//从尾端开始创建最大堆，每次都是正确的堆<br>  for(int i=startIndex;i&gt;=0;i–){<br>   maxHeapify(data,data.length,i);<br>  }<br> }</p>\n<p> /*<em>\n  </em>创建最大堆<br>  <em>\n  </em>@paramdata<br>  <em>@paramheapSize需要创建最大堆的大小，一般在sort的时候用到，因为最多值放在末尾，末尾就不再归入最大堆了\n  </em>@paramindex当前需要创建最大堆的位置<br>  */<br> private static void maxHeapify(int[] data,int heapSize,int index){<br>//当前点与左右子节点比较<br>  int left=getChildLeftIndex(index);<br>  int right=getChildRightIndex(index);</p>\n<p>  int largest=index;<br>  if(left&lt;heapSize&amp;&amp;data[index]&lt;data[left]){<br>   largest=left;<br>  }<br>  if(right&lt;heapSize&amp;&amp;data[largest]&lt;data[right]){<br>   largest=right;<br>  }<br>//得到最大值后可能需要交换，如果交换了，其子节点可能就不是最大堆了，需要重新调整<br>  if(largest!=index){<br>   int temp=data[index];<br>   data[index]=data[largest];<br>   data[largest]=temp;<br>   maxHeapify(data,heapSize,largest);<br>  }<br> }</p>\n<p> /*<em>\n  </em>排序，最大值放在末尾，data虽然是最大堆，在排序后就成了递增的<br>  <em>\n  </em>@paramdata<br>  */<br> private static void heapSort(int[] data){<br>//末尾与头交换，交换后调整最大堆<br>  for(int i=data.length-1;i&gt;0;i–){<br>   int temp=data[0];<br>   data[0]=data[i];<br>   data[i]=temp;<br>   maxHeapify(data,i,0);<br>  }<br> }</p>\n<p> /*<em>\n  </em>父节点位置<br>  <em>\n  </em>@paramcurrent<br>  <em>@return\n  </em>/<br> private static int getParentIndex(int current){<br>  return(current-1)&gt;&gt;1;<br> }</p>\n<p> /*<em>\n  </em>左子节点position注意括号，加法优先级更高<br>  <em>\n  </em>@paramcurrent<br>  <em>@return\n  </em>/<br> private static int getChildLeftIndex(int current){<br>  return(current&lt;&lt;1)+1;<br> }</p>\n<p> /*<em>\n  </em>右子节点position<br>  <em>\n  </em>@paramcurrent<br>  <em>@return\n  </em>/<br> private static int getChildRightIndex(int current){<br>  return(current&lt;&lt;1)+2;<br> }</p>\n<p> private static void print(int[] data){<br>  int pre=-2;<br>  for(int i=0;i&lt;data.length;i++){<br>   if(pre&lt;(int)getLog(i+1)){<br>    pre=(int)getLog(i+1);<br>    System.out.println();<br>   }<br>   System.out.print(data[i]+”|”);<br>  }<br> }</p>\n<p> /*<em>\n  </em>以2为底的对数<br>  <em>\n  </em>@paramparam<br>  <em>@return\n  </em>/<br> private static double getLog(double param){<br>  return Math.log(param)/Math.log(2);<br> }<br>}</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一、基础知识<br>我们通常所说的堆是指二叉堆，二叉堆又称完全二叉树或者叫近似完全二叉树。二叉堆又分为最大堆和最小堆。<br>堆排序(Heapsort)是指利用堆这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。数组可以根据索引直接获取元素，时间复杂度为O（1），也就是常量，因此对于取值效率极高。<br>最大堆的特性如下：</p>\n<p>父结点的键值总是大于或者等于任何一个子节点的键值<br>每个结点的左子树和右子树都是一个最大堆<br>最小堆的特性如下：</p>\n<p>父结点的键值总是小于或者等于任何一个子节点的键值<br>每个结点的左子树和右子树都是一个最小堆<br>二、算法思想<br>1.最大堆的算法思想是：<br>先将初始的R[0…n-1]建立成最大堆，此时是无序堆，而堆顶是最大元素<br>再将堆顶R[0]和无序区的最后一个记录R[n-1]交换，由此得到新的无序区R[0…n-2]和有序区R[n-1]，且满足R[0…n-2].keys ≤ R[n-1].key<br>由于交换后，前R[0…n-2]可能不满足最大堆的性质，因此再调整前R[0…n-2]为最大堆，直到只有R[0]最后一个元素才调整完成。<br>最大堆排序完成后，其实是升序序列，每次调整堆都是要得到最大的一个元素，然后与当前堆的最后一个元素交换，因此最后所得到的序列是升序序列。<br>2.最小堆的算法思想是：<br>先将初始的R[0…n-1]建立成最小堆，此时是无序堆，而堆顶元素是最小的元素<br>再将堆顶R[0]与无序区的最后一个R[n-1]交换，由此得到新的无序堆R[0…n-2]和有序堆R[n-1]，且满足R[0…n-2].keys &gt;= R[n-1].key<br>由于交换后，前R[0…n-2]可能不满足最小堆的性质，因此再调整前R[0…n-2]为最小堆，直到只有R[0]最后一个元素才调整完成<br>最小堆排序完成后，其实是降序序列，每次调整堆都是要得到最小的一个元素，然后与当前无序堆的最后一个元素交换，所以所得到的序列是降序的。<br>提示：堆排序的过程，其实就是不断地扩大有序区，然后不断地缩小无序区，直到只有有序区的过程。</p>\n<p>三、排序过程分析<br>因为算法比较抽象，这里直接通过举个小例子来说明堆排序的过程是如何的。下面我们用这个无序序列采用最大堆的进行堆排序，所得到的序列就是升序序列（ASC）。<br>无序序列：89,-7,999,-89,7,0,-888,7,-7<br>第一步：初始化建成最大堆：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"\\堆排序\\dui1.png\" alt=\"图片\" title=\"\">\n                </div>\n                <div class=\"image-caption\">图片</div>\n            </figure></p>\n<p>第二步：将堆顶最大元素999与无序区的最后一个元素交换，使999成为有序区。交换后，-7成为堆顶，由于-7并不是无序区中最大的元素，因此需要调整无序区，使无序区中最大值89成为堆顶，所以-7与89交换。交换后导致89的右子树不满足最大堆的性质，因此要对右子树调整成最大堆，所以-7要与0交换，如下图：<br><figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"\\堆排序\\dui2.jpg\" alt=\"图片\" title=\"\">\n                </div>\n                <div class=\"image-caption\">图片</div>\n            </figure></p>\n<p>从图中看到，当-7成89交换后，堆顶是最大元素了，但是-7的左孩子是0，右孩子是-888，由于-7&lt;0，导致-7这个结点不满足堆的性质，因此需要调整它。所以，0与-7交换。<br>然后不断重复着第二步的过程，直到全部成为有序区。<br>最后：所得到的是升序序列</p>\n<figure class=\"image-bubble\">\n                <div class=\"img-lightbox\">\n                    <div class=\"overlay\"></div>\n                    <img src=\"\\堆排序\\dui3.jpg\" alt=\"图片\" title=\"\">\n                </div>\n                <div class=\"image-caption\">图片</div>\n            </figure>\n<p>四、时间复杂度<br>堆排序的时间，主要由建立初始堆和反复调整堆这两部分的时间开销构成.由于堆排序是不稳定的，它得扭到的时间复杂度会根据实际情况较大，因此只能取平均时间复杂度。<br>平均时间复杂度为：O( N <em> log2(N) )<br>堆排序耗时的操作有：初始堆 + 反复调整堆，时间复杂度如下：<br>1.初始建堆：每个父节点会和左右子节点进行最多2次比较和1次交换，所以复杂度跟父节点个数有关。根据2x &lt;= n（x为n个元素可以折半的次数，也就是父节点个数），得出x = log2n。即O ( log2n )<br>2.反复调整堆：由于初始化堆过程中，会记录数组比较结果，所以堆排序对原序列的数组顺序并不敏感，最好情况和最坏情况差不多。需要抽取 n-1 次堆顶元素，每次取堆顶元素都需要重建堆（O(重建堆) &lt; O(初始堆)）。所以小于 O(n-1) </em> O(log2n)<br>使用建议：<br>由于初始化堆需要比较的次数较多，因此，堆排序比较适合于数据量非常大的场合（百万数据或更多）。由于高效的快速排序是基于递归实现的，所以在数据量非常大时会发生堆栈溢出错误。</p>\n<p>五、Java示例代码</p>\n<p>public class HeapSort{<br> private static int[] sort=new int[]{1,0,10,20,3,5,6,4,9,8,12,<br>   17,34,11};</p>\n<p> public static void main(String[] args){<br>  buildMaxHeapify(sort);<br>  heapSort(sort);<br>  print(sort);<br> }</p>\n<p> private static void buildMaxHeapify(int[] data){<br>//没有子节点的才需要创建最大堆，从最后一个的父节点开始<br>  int startIndex=getParentIndex(data.length-1);<br>//从尾端开始创建最大堆，每次都是正确的堆<br>  for(int i=startIndex;i&gt;=0;i–){<br>   maxHeapify(data,data.length,i);<br>  }<br> }</p>\n<p> /*<em>\n  </em>创建最大堆<br>  <em>\n  </em>@paramdata<br>  <em>@paramheapSize需要创建最大堆的大小，一般在sort的时候用到，因为最多值放在末尾，末尾就不再归入最大堆了\n  </em>@paramindex当前需要创建最大堆的位置<br>  */<br> private static void maxHeapify(int[] data,int heapSize,int index){<br>//当前点与左右子节点比较<br>  int left=getChildLeftIndex(index);<br>  int right=getChildRightIndex(index);</p>\n<p>  int largest=index;<br>  if(left&lt;heapSize&amp;&amp;data[index]&lt;data[left]){<br>   largest=left;<br>  }<br>  if(right&lt;heapSize&amp;&amp;data[largest]&lt;data[right]){<br>   largest=right;<br>  }<br>//得到最大值后可能需要交换，如果交换了，其子节点可能就不是最大堆了，需要重新调整<br>  if(largest!=index){<br>   int temp=data[index];<br>   data[index]=data[largest];<br>   data[largest]=temp;<br>   maxHeapify(data,heapSize,largest);<br>  }<br> }</p>\n<p> /*<em>\n  </em>排序，最大值放在末尾，data虽然是最大堆，在排序后就成了递增的<br>  <em>\n  </em>@paramdata<br>  */<br> private static void heapSort(int[] data){<br>//末尾与头交换，交换后调整最大堆<br>  for(int i=data.length-1;i&gt;0;i–){<br>   int temp=data[0];<br>   data[0]=data[i];<br>   data[i]=temp;<br>   maxHeapify(data,i,0);<br>  }<br> }</p>\n<p> /*<em>\n  </em>父节点位置<br>  <em>\n  </em>@paramcurrent<br>  <em>@return\n  </em>/<br> private static int getParentIndex(int current){<br>  return(current-1)&gt;&gt;1;<br> }</p>\n<p> /*<em>\n  </em>左子节点position注意括号，加法优先级更高<br>  <em>\n  </em>@paramcurrent<br>  <em>@return\n  </em>/<br> private static int getChildLeftIndex(int current){<br>  return(current&lt;&lt;1)+1;<br> }</p>\n<p> /*<em>\n  </em>右子节点position<br>  <em>\n  </em>@paramcurrent<br>  <em>@return\n  </em>/<br> private static int getChildRightIndex(int current){<br>  return(current&lt;&lt;1)+2;<br> }</p>\n<p> private static void print(int[] data){<br>  int pre=-2;<br>  for(int i=0;i&lt;data.length;i++){<br>   if(pre&lt;(int)getLog(i+1)){<br>    pre=(int)getLog(i+1);<br>    System.out.println();<br>   }<br>   System.out.print(data[i]+”|”);<br>  }<br> }</p>\n<p> /*<em>\n  </em>以2为底的对数<br>  <em>\n  </em>@paramparam<br>  <em>@return\n  </em>/<br> private static double getLog(double param){<br>  return Math.log(param)/Math.log(2);<br> }<br>}</p>\n"},{"title":"归并排序","date":"2018-04-16T15:20:40.000Z","_content":"归并排序是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)，1945年由冯·诺伊曼首次提出。\n归并排序算法主要依赖归并(Merge)操作。归并操作指的是将两个已经排序的序列合并成一个序列的操作，归并操作步骤如下：\n        1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列\n        2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置\n        3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置\n        4. 重复步骤3直到某一指针到达序列尾\n        5. 将另一序列剩下的所有元素直接复制到合并序列尾\n归并排序的代码如下：\n\n#include <stdio.h>\n#include <limits.h>\n// 分类 -------------- 内部比较排序\n// 数据结构 ---------- 数组\n// 最差时间复杂度 ---- O(nlogn)\n// 最优时间复杂度 ---- O(nlogn)\n// 平均时间复杂度 ---- O(nlogn)\n// 所需辅助空间 ------ O(n)\n// 稳定性 ------------ 稳定\nvoid Merge(int A[], int left, int mid, int right)// 合并两个已排好序的数组A[left...mid]和A[mid+1...right]\n{\n    int len = right - left + 1;\n    int *temp = new int[len];       // 辅助空间O(n)\n    int index = 0;\n    int i = left;                   // 前一数组的起始元素\n    int j = mid + 1;                // 后一数组的起始元素\n    while (i <= mid && j <= right)\n    {\n        temp[index++] = A[i] <= A[j] ? A[i++] : A[j++];  // 带等号保证归并排序的稳定性\n    }\n    while (i <= mid)\n    {\n        temp[index++] = A[i++];\n    }\n    while (j <= right)\n    {\n        temp[index++] = A[j++];\n    }\n    for (int k = 0; k < len; k++)\n    {\n        A[left++] = temp[k];\n    }\n}\nvoid MergeSortRecursion(int A[], int left, int right)    // 递归实现的归并排序(自顶向下)\n{\n    if (left == right)    // 当待排序的序列长度为1时，递归开始回溯，进行merge操作\n        return;\n    int mid = (left + right) / 2;\n    MergeSortRecursion(A, left, mid);\n    MergeSortRecursion(A, mid + 1, right);\n    Merge(A, left, mid, right);\n}\nvoid MergeSortIteration(int A[], int len)    // 非递归(迭代)实现的归并排序(自底向上)\n{\n    int left, mid, right;// 子数组索引,前一个为A[left...mid]，后一个子数组为A[mid+1...right]\n    for (int i = 1; i < len; i *= 2)        // 子数组的大小i初始为1，每轮翻倍\n    {\n        left = 0;\n        while (left + i < len)              // 后一个子数组存在(需要归并)\n        {\n            mid = left + i - 1;\n            right = mid + i < len ? mid + i : len - 1;// 后一个子数组大小可能不够\n            Merge(A, left, mid, right);\n            left = right + 1;               // 前一个子数组索引向后移动\n        }\n    }\n}\nint main()\n{\n    int A1[] = { 6, 5, 3, 1, 8, 7, 2, 4 };      // 从小到大归并排序\n    int A2[] = { 6, 5, 3, 1, 8, 7, 2, 4 };\n    int n1 = sizeof(A1) / sizeof(int);\n    int n2 = sizeof(A2) / sizeof(int);\n    MergeSortRecursion(A1, 0, n1 - 1);          // 递归实现\n    MergeSortIteration(A2, n2);                 // 非递归实现\n    printf(\"递归实现的归并排序结果：\");\n    for (int i = 0; i < n1; i++)\n    {\n        printf(\"%d \", A1[i]);\n    }\n    printf(\"\\n\");\n    printf(\"非递归实现的归并排序结果：\");\n    for (int i = 0; i < n2; i++)\n    {\n        printf(\"%d \", A2[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \n上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行归并排序的实例如下\n \n\n使用归并排序为一列数字进行排序的宏观过程：\n\n归并排序除了可以对数组进行排序，还可以高效的求出数组小和（即单调和）以及数组中的逆序对，详见这篇博文。\n","source":"_posts/归并排序.md","raw":"---\ntitle: 归并排序\ntags: \n- 算法排序\n- 基础知识\ncategories: \n- 基础知识\n- 算法排序\ndate: 2018-04-16 23:20:40\n---\n归并排序是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)，1945年由冯·诺伊曼首次提出。\n归并排序算法主要依赖归并(Merge)操作。归并操作指的是将两个已经排序的序列合并成一个序列的操作，归并操作步骤如下：\n        1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列\n        2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置\n        3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置\n        4. 重复步骤3直到某一指针到达序列尾\n        5. 将另一序列剩下的所有元素直接复制到合并序列尾\n归并排序的代码如下：\n\n#include <stdio.h>\n#include <limits.h>\n// 分类 -------------- 内部比较排序\n// 数据结构 ---------- 数组\n// 最差时间复杂度 ---- O(nlogn)\n// 最优时间复杂度 ---- O(nlogn)\n// 平均时间复杂度 ---- O(nlogn)\n// 所需辅助空间 ------ O(n)\n// 稳定性 ------------ 稳定\nvoid Merge(int A[], int left, int mid, int right)// 合并两个已排好序的数组A[left...mid]和A[mid+1...right]\n{\n    int len = right - left + 1;\n    int *temp = new int[len];       // 辅助空间O(n)\n    int index = 0;\n    int i = left;                   // 前一数组的起始元素\n    int j = mid + 1;                // 后一数组的起始元素\n    while (i <= mid && j <= right)\n    {\n        temp[index++] = A[i] <= A[j] ? A[i++] : A[j++];  // 带等号保证归并排序的稳定性\n    }\n    while (i <= mid)\n    {\n        temp[index++] = A[i++];\n    }\n    while (j <= right)\n    {\n        temp[index++] = A[j++];\n    }\n    for (int k = 0; k < len; k++)\n    {\n        A[left++] = temp[k];\n    }\n}\nvoid MergeSortRecursion(int A[], int left, int right)    // 递归实现的归并排序(自顶向下)\n{\n    if (left == right)    // 当待排序的序列长度为1时，递归开始回溯，进行merge操作\n        return;\n    int mid = (left + right) / 2;\n    MergeSortRecursion(A, left, mid);\n    MergeSortRecursion(A, mid + 1, right);\n    Merge(A, left, mid, right);\n}\nvoid MergeSortIteration(int A[], int len)    // 非递归(迭代)实现的归并排序(自底向上)\n{\n    int left, mid, right;// 子数组索引,前一个为A[left...mid]，后一个子数组为A[mid+1...right]\n    for (int i = 1; i < len; i *= 2)        // 子数组的大小i初始为1，每轮翻倍\n    {\n        left = 0;\n        while (left + i < len)              // 后一个子数组存在(需要归并)\n        {\n            mid = left + i - 1;\n            right = mid + i < len ? mid + i : len - 1;// 后一个子数组大小可能不够\n            Merge(A, left, mid, right);\n            left = right + 1;               // 前一个子数组索引向后移动\n        }\n    }\n}\nint main()\n{\n    int A1[] = { 6, 5, 3, 1, 8, 7, 2, 4 };      // 从小到大归并排序\n    int A2[] = { 6, 5, 3, 1, 8, 7, 2, 4 };\n    int n1 = sizeof(A1) / sizeof(int);\n    int n2 = sizeof(A2) / sizeof(int);\n    MergeSortRecursion(A1, 0, n1 - 1);          // 递归实现\n    MergeSortIteration(A2, n2);                 // 非递归实现\n    printf(\"递归实现的归并排序结果：\");\n    for (int i = 0; i < n1; i++)\n    {\n        printf(\"%d \", A1[i]);\n    }\n    printf(\"\\n\");\n    printf(\"非递归实现的归并排序结果：\");\n    for (int i = 0; i < n2; i++)\n    {\n        printf(\"%d \", A2[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \n上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行归并排序的实例如下\n \n\n使用归并排序为一列数字进行排序的宏观过程：\n\n归并排序除了可以对数组进行排序，还可以高效的求出数组小和（即单调和）以及数组中的逆序对，详见这篇博文。\n","slug":"归并排序","published":1,"updated":"2018-04-29T06:42:47.063Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgkim7zm000diku7kne4ciut","content":"<p>归并排序是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)，1945年由冯·诺伊曼首次提出。<br>归并排序算法主要依赖归并(Merge)操作。归并操作指的是将两个已经排序的序列合并成一个序列的操作，归并操作步骤如下：</p>\n<pre><code>1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列\n2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置\n3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置\n4. 重复步骤3直到某一指针到达序列尾\n5. 将另一序列剩下的所有元素直接复制到合并序列尾\n</code></pre><p>归并排序的代码如下：</p>\n<p>#include &lt;stdio.h&gt;</p>\n<p>#include &lt;limits.h&gt;<br>// 分类 ————– 内部比较排序<br>// 数据结构 ———- 数组<br>// 最差时间复杂度 —- O(nlogn)<br>// 最优时间复杂度 —- O(nlogn)<br>// 平均时间复杂度 —- O(nlogn)<br>// 所需辅助空间 —— O(n)<br>// 稳定性 ———— 稳定<br>void Merge(int A[], int left, int mid, int right)// 合并两个已排好序的数组A[left…mid]和A[mid+1…right]<br>{<br>    int len = right - left + 1;<br>    int <em>temp = new int[len];       // 辅助空间O(n)<br>    int index = 0;<br>    int i = left;                   // 前一数组的起始元素<br>    int j = mid + 1;                // 后一数组的起始元素<br>    while (i &lt;= mid &amp;&amp; j &lt;= right)<br>    {<br>        temp[index++] = A[i] &lt;= A[j] ? A[i++] : A[j++];  // 带等号保证归并排序的稳定性<br>    }<br>    while (i &lt;= mid)<br>    {<br>        temp[index++] = A[i++];<br>    }<br>    while (j &lt;= right)<br>    {<br>        temp[index++] = A[j++];<br>    }<br>    for (int k = 0; k &lt; len; k++)<br>    {<br>        A[left++] = temp[k];<br>    }<br>}<br>void MergeSortRecursion(int A[], int left, int right)    // 递归实现的归并排序(自顶向下)<br>{<br>    if (left == right)    // 当待排序的序列长度为1时，递归开始回溯，进行merge操作<br>        return;<br>    int mid = (left + right) / 2;<br>    MergeSortRecursion(A, left, mid);<br>    MergeSortRecursion(A, mid + 1, right);<br>    Merge(A, left, mid, right);<br>}<br>void MergeSortIteration(int A[], int len)    // 非递归(迭代)实现的归并排序(自底向上)<br>{<br>    int left, mid, right;// 子数组索引,前一个为A[left…mid]，后一个子数组为A[mid+1…right]<br>    for (int i = 1; i &lt; len; i </em>= 2)        // 子数组的大小i初始为1，每轮翻倍<br>    {<br>        left = 0;<br>        while (left + i &lt; len)              // 后一个子数组存在(需要归并)<br>        {<br>            mid = left + i - 1;<br>            right = mid + i &lt; len ? mid + i : len - 1;// 后一个子数组大小可能不够<br>            Merge(A, left, mid, right);<br>            left = right + 1;               // 前一个子数组索引向后移动<br>        }<br>    }<br>}<br>int main()<br>{<br>    int A1[] = { 6, 5, 3, 1, 8, 7, 2, 4 };      // 从小到大归并排序<br>    int A2[] = { 6, 5, 3, 1, 8, 7, 2, 4 };<br>    int n1 = sizeof(A1) / sizeof(int);<br>    int n2 = sizeof(A2) / sizeof(int);<br>    MergeSortRecursion(A1, 0, n1 - 1);          // 递归实现<br>    MergeSortIteration(A2, n2);                 // 非递归实现<br>    printf(“递归实现的归并排序结果：”);<br>    for (int i = 0; i &lt; n1; i++)<br>    {<br>        printf(“%d “, A1[i]);<br>    }<br>    printf(“\\n”);<br>    printf(“非递归实现的归并排序结果：”);<br>    for (int i = 0; i &lt; n2; i++)<br>    {<br>        printf(“%d “, A2[i]);<br>    }<br>    printf(“\\n”);<br>    return 0;<br>}</p>\n<p>上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行归并排序的实例如下</p>\n<p>使用归并排序为一列数字进行排序的宏观过程：</p>\n<p>归并排序除了可以对数组进行排序，还可以高效的求出数组小和（即单调和）以及数组中的逆序对，详见这篇博文。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>归并排序是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)，1945年由冯·诺伊曼首次提出。<br>归并排序算法主要依赖归并(Merge)操作。归并操作指的是将两个已经排序的序列合并成一个序列的操作，归并操作步骤如下：</p>\n<pre><code>1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列\n2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置\n3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置\n4. 重复步骤3直到某一指针到达序列尾\n5. 将另一序列剩下的所有元素直接复制到合并序列尾\n</code></pre><p>归并排序的代码如下：</p>\n<p>#include &lt;stdio.h&gt;</p>\n<p>#include &lt;limits.h&gt;<br>// 分类 ————– 内部比较排序<br>// 数据结构 ———- 数组<br>// 最差时间复杂度 —- O(nlogn)<br>// 最优时间复杂度 —- O(nlogn)<br>// 平均时间复杂度 —- O(nlogn)<br>// 所需辅助空间 —— O(n)<br>// 稳定性 ———— 稳定<br>void Merge(int A[], int left, int mid, int right)// 合并两个已排好序的数组A[left…mid]和A[mid+1…right]<br>{<br>    int len = right - left + 1;<br>    int <em>temp = new int[len];       // 辅助空间O(n)<br>    int index = 0;<br>    int i = left;                   // 前一数组的起始元素<br>    int j = mid + 1;                // 后一数组的起始元素<br>    while (i &lt;= mid &amp;&amp; j &lt;= right)<br>    {<br>        temp[index++] = A[i] &lt;= A[j] ? A[i++] : A[j++];  // 带等号保证归并排序的稳定性<br>    }<br>    while (i &lt;= mid)<br>    {<br>        temp[index++] = A[i++];<br>    }<br>    while (j &lt;= right)<br>    {<br>        temp[index++] = A[j++];<br>    }<br>    for (int k = 0; k &lt; len; k++)<br>    {<br>        A[left++] = temp[k];<br>    }<br>}<br>void MergeSortRecursion(int A[], int left, int right)    // 递归实现的归并排序(自顶向下)<br>{<br>    if (left == right)    // 当待排序的序列长度为1时，递归开始回溯，进行merge操作<br>        return;<br>    int mid = (left + right) / 2;<br>    MergeSortRecursion(A, left, mid);<br>    MergeSortRecursion(A, mid + 1, right);<br>    Merge(A, left, mid, right);<br>}<br>void MergeSortIteration(int A[], int len)    // 非递归(迭代)实现的归并排序(自底向上)<br>{<br>    int left, mid, right;// 子数组索引,前一个为A[left…mid]，后一个子数组为A[mid+1…right]<br>    for (int i = 1; i &lt; len; i </em>= 2)        // 子数组的大小i初始为1，每轮翻倍<br>    {<br>        left = 0;<br>        while (left + i &lt; len)              // 后一个子数组存在(需要归并)<br>        {<br>            mid = left + i - 1;<br>            right = mid + i &lt; len ? mid + i : len - 1;// 后一个子数组大小可能不够<br>            Merge(A, left, mid, right);<br>            left = right + 1;               // 前一个子数组索引向后移动<br>        }<br>    }<br>}<br>int main()<br>{<br>    int A1[] = { 6, 5, 3, 1, 8, 7, 2, 4 };      // 从小到大归并排序<br>    int A2[] = { 6, 5, 3, 1, 8, 7, 2, 4 };<br>    int n1 = sizeof(A1) / sizeof(int);<br>    int n2 = sizeof(A2) / sizeof(int);<br>    MergeSortRecursion(A1, 0, n1 - 1);          // 递归实现<br>    MergeSortIteration(A2, n2);                 // 非递归实现<br>    printf(“递归实现的归并排序结果：”);<br>    for (int i = 0; i &lt; n1; i++)<br>    {<br>        printf(“%d “, A1[i]);<br>    }<br>    printf(“\\n”);<br>    printf(“非递归实现的归并排序结果：”);<br>    for (int i = 0; i &lt; n2; i++)<br>    {<br>        printf(“%d “, A2[i]);<br>    }<br>    printf(“\\n”);<br>    return 0;<br>}</p>\n<p>上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行归并排序的实例如下</p>\n<p>使用归并排序为一列数字进行排序的宏观过程：</p>\n<p>归并排序除了可以对数组进行排序，还可以高效的求出数组小和（即单调和）以及数组中的逆序对，详见这篇博文。</p>\n"},{"title":"快速排序","date":"2018-04-16T15:20:40.000Z","_content":"快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序n个元素要O(nlogn)次比较。在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他O(nlogn)算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。\n快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。步骤为：\n        1. 从序列中挑出一个元素，作为\"基准\"(pivot).\n        2. 把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），这个称为分区(partition)操作。\n        3. 对每个分区递归地进行步骤1~2，递归的结束条件是序列的大小是0或1，这时整体已经被排好序了。\n快速排序的代码如下：\n\n#include <stdio.h>\n// 分类 ------------ 内部比较排序\n// 数据结构 --------- 数组\n// 最差时间复杂度 ---- 每次选取的基准都是最大（或最小）的元素，导致每次只划分出了一个分区，需要进行n-1次划分才能结束递归，时间复杂度为O(n^2)\n// 最优时间复杂度 ---- 每次选取的基准都是中位数，这样每次都均匀的划分出两个分区，只需要logn次划分就能结束递归，时间复杂度为O(nlogn)\n// 平均时间复杂度 ---- O(nlogn)\n// 所需辅助空间 ------ 主要是递归造成的栈空间的使用(用来保存left和right等局部变量)，取决于递归树的深度，一般为O(logn)，最差为O(n)       \n// 稳定性 ---------- 不稳定\nvoid Swap(int A[], int i, int j)\n{\n    int temp = A[i];\n    A[i] = A[j];\n    A[j] = temp;\n}\nint Partition(int A[], int left, int right)  // 划分函数\n{\n    int pivot = A[right];               // 这里每次都选择最后一个元素作为基准\n    int tail = left - 1;                // tail为小于基准的子数组最后一个元素的索引\n    for (int i = left; i < right; i++)  // 遍历基准以外的其他元素\n    {\n        if (A[i] <= pivot)              // 把小于等于基准的元素放到前一个子数组末尾\n        {\n            Swap(A, ++tail, i);\n        }\n    }\n    Swap(A, tail + 1, right);           // 最后把基准放到前一个子数组的后边，剩下的子数组既是大于基准的子数组\n                                        // 该操作很有可能把后面元素的稳定性打乱，所以快速排序是不稳定的排序算法\n    return tail + 1;                    // 返回基准的索引\n}\nvoid QuickSort(int A[], int left, int right)\n{\n    if (left >= right)\n        return;\n    int pivot_index = Partition(A, left, right); // 基准的索引\n    QuickSort(A, left, pivot_index - 1);\n    QuickSort(A, pivot_index + 1, right);\n}\nint main()\n{\n    int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 }; // 从小到大快速排序\n    int n = sizeof(A) / sizeof(int);\n    QuickSort(A, 0, n - 1);\n    printf(\"快速排序结果：\");\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \", A[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \n使用快速排序法对一列数字进行排序的过程：\n\n \n快速排序是不稳定的排序算法，不稳定发生在基准元素与A[tail+1]交换的时刻。\n比如序列：{ 1, 3, 4, 2, 8, 9, 8, 7, 5 }，基准元素是5，一次划分操作后5要和第一个8进行交换，从而改变了两个元素8的相对次序。\n \nJava系统提供的Arrays.sort函数。对于基础类型，底层使用快速排序。对于非基础类型，底层使用归并排序。请问是为什么？\n答：这是考虑到排序算法的稳定性。对于基础类型，相同值是无差别的，排序前后相同值的相对位置并不重要，所以选择更为高效的快速排序，尽管它是不稳定的排序算法；而对于非基础类型，排序前后相等实例的相对位置不宜改变，所以选择稳定的归并排序。 \n","source":"_posts/快速排序.md","raw":"---\ntitle: 快速排序\ntags: \n- 算法排序\n- 基础知识\ncategories: \n- 基础知识\n- 算法排序\ndate: 2018-04-16 23:20:40\n---\n快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序n个元素要O(nlogn)次比较。在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他O(nlogn)算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。\n快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。步骤为：\n        1. 从序列中挑出一个元素，作为\"基准\"(pivot).\n        2. 把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），这个称为分区(partition)操作。\n        3. 对每个分区递归地进行步骤1~2，递归的结束条件是序列的大小是0或1，这时整体已经被排好序了。\n快速排序的代码如下：\n\n#include <stdio.h>\n// 分类 ------------ 内部比较排序\n// 数据结构 --------- 数组\n// 最差时间复杂度 ---- 每次选取的基准都是最大（或最小）的元素，导致每次只划分出了一个分区，需要进行n-1次划分才能结束递归，时间复杂度为O(n^2)\n// 最优时间复杂度 ---- 每次选取的基准都是中位数，这样每次都均匀的划分出两个分区，只需要logn次划分就能结束递归，时间复杂度为O(nlogn)\n// 平均时间复杂度 ---- O(nlogn)\n// 所需辅助空间 ------ 主要是递归造成的栈空间的使用(用来保存left和right等局部变量)，取决于递归树的深度，一般为O(logn)，最差为O(n)       \n// 稳定性 ---------- 不稳定\nvoid Swap(int A[], int i, int j)\n{\n    int temp = A[i];\n    A[i] = A[j];\n    A[j] = temp;\n}\nint Partition(int A[], int left, int right)  // 划分函数\n{\n    int pivot = A[right];               // 这里每次都选择最后一个元素作为基准\n    int tail = left - 1;                // tail为小于基准的子数组最后一个元素的索引\n    for (int i = left; i < right; i++)  // 遍历基准以外的其他元素\n    {\n        if (A[i] <= pivot)              // 把小于等于基准的元素放到前一个子数组末尾\n        {\n            Swap(A, ++tail, i);\n        }\n    }\n    Swap(A, tail + 1, right);           // 最后把基准放到前一个子数组的后边，剩下的子数组既是大于基准的子数组\n                                        // 该操作很有可能把后面元素的稳定性打乱，所以快速排序是不稳定的排序算法\n    return tail + 1;                    // 返回基准的索引\n}\nvoid QuickSort(int A[], int left, int right)\n{\n    if (left >= right)\n        return;\n    int pivot_index = Partition(A, left, right); // 基准的索引\n    QuickSort(A, left, pivot_index - 1);\n    QuickSort(A, pivot_index + 1, right);\n}\nint main()\n{\n    int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 }; // 从小到大快速排序\n    int n = sizeof(A) / sizeof(int);\n    QuickSort(A, 0, n - 1);\n    printf(\"快速排序结果：\");\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \", A[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \n使用快速排序法对一列数字进行排序的过程：\n\n \n快速排序是不稳定的排序算法，不稳定发生在基准元素与A[tail+1]交换的时刻。\n比如序列：{ 1, 3, 4, 2, 8, 9, 8, 7, 5 }，基准元素是5，一次划分操作后5要和第一个8进行交换，从而改变了两个元素8的相对次序。\n \nJava系统提供的Arrays.sort函数。对于基础类型，底层使用快速排序。对于非基础类型，底层使用归并排序。请问是为什么？\n答：这是考虑到排序算法的稳定性。对于基础类型，相同值是无差别的，排序前后相同值的相对位置并不重要，所以选择更为高效的快速排序，尽管它是不稳定的排序算法；而对于非基础类型，排序前后相等实例的相对位置不宜改变，所以选择稳定的归并排序。 \n","slug":"快速排序","published":1,"updated":"2018-04-29T06:42:47.072Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgkim7zp000fiku7gngd8y65","content":"<p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序n个元素要O(nlogn)次比较。在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他O(nlogn)算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。<br>快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。步骤为：</p>\n<pre><code>1. 从序列中挑出一个元素，作为&quot;基准&quot;(pivot).\n2. 把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），这个称为分区(partition)操作。\n3. 对每个分区递归地进行步骤1~2，递归的结束条件是序列的大小是0或1，这时整体已经被排好序了。\n</code></pre><p>快速排序的代码如下：</p>\n<p>#include &lt;stdio.h&gt;<br>// 分类 ———— 内部比较排序<br>// 数据结构 ——— 数组<br>// 最差时间复杂度 —- 每次选取的基准都是最大（或最小）的元素，导致每次只划分出了一个分区，需要进行n-1次划分才能结束递归，时间复杂度为O(n^2)<br>// 最优时间复杂度 —- 每次选取的基准都是中位数，这样每次都均匀的划分出两个分区，只需要logn次划分就能结束递归，时间复杂度为O(nlogn)<br>// 平均时间复杂度 —- O(nlogn)<br>// 所需辅助空间 —— 主要是递归造成的栈空间的使用(用来保存left和right等局部变量)，取决于递归树的深度，一般为O(logn)，最差为O(n)<br>// 稳定性 ———- 不稳定<br>void Swap(int A[], int i, int j)<br>{<br>    int temp = A[i];<br>    A[i] = A[j];<br>    A[j] = temp;<br>}<br>int Partition(int A[], int left, int right)  // 划分函数<br>{<br>    int pivot = A[right];               // 这里每次都选择最后一个元素作为基准<br>    int tail = left - 1;                // tail为小于基准的子数组最后一个元素的索引<br>    for (int i = left; i &lt; right; i++)  // 遍历基准以外的其他元素<br>    {<br>        if (A[i] &lt;= pivot)              // 把小于等于基准的元素放到前一个子数组末尾<br>        {<br>            Swap(A, ++tail, i);<br>        }<br>    }<br>    Swap(A, tail + 1, right);           // 最后把基准放到前一个子数组的后边，剩下的子数组既是大于基准的子数组<br>                                        // 该操作很有可能把后面元素的稳定性打乱，所以快速排序是不稳定的排序算法<br>    return tail + 1;                    // 返回基准的索引<br>}<br>void QuickSort(int A[], int left, int right)<br>{<br>    if (left &gt;= right)<br>        return;<br>    int pivot_index = Partition(A, left, right); // 基准的索引<br>    QuickSort(A, left, pivot_index - 1);<br>    QuickSort(A, pivot_index + 1, right);<br>}<br>int main()<br>{<br>    int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 }; // 从小到大快速排序<br>    int n = sizeof(A) / sizeof(int);<br>    QuickSort(A, 0, n - 1);<br>    printf(“快速排序结果：”);<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        printf(“%d “, A[i]);<br>    }<br>    printf(“\\n”);<br>    return 0;<br>}</p>\n<p>使用快速排序法对一列数字进行排序的过程：</p>\n<p>快速排序是不稳定的排序算法，不稳定发生在基准元素与A[tail+1]交换的时刻。<br>比如序列：{ 1, 3, 4, 2, 8, 9, 8, 7, 5 }，基准元素是5，一次划分操作后5要和第一个8进行交换，从而改变了两个元素8的相对次序。</p>\n<p>Java系统提供的Arrays.sort函数。对于基础类型，底层使用快速排序。对于非基础类型，底层使用归并排序。请问是为什么？<br>答：这是考虑到排序算法的稳定性。对于基础类型，相同值是无差别的，排序前后相同值的相对位置并不重要，所以选择更为高效的快速排序，尽管它是不稳定的排序算法；而对于非基础类型，排序前后相等实例的相对位置不宜改变，所以选择稳定的归并排序。 </p>\n","site":{"data":{}},"excerpt":"","more":"<p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序n个元素要O(nlogn)次比较。在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他O(nlogn)算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。<br>快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。步骤为：</p>\n<pre><code>1. 从序列中挑出一个元素，作为&quot;基准&quot;(pivot).\n2. 把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），这个称为分区(partition)操作。\n3. 对每个分区递归地进行步骤1~2，递归的结束条件是序列的大小是0或1，这时整体已经被排好序了。\n</code></pre><p>快速排序的代码如下：</p>\n<p>#include &lt;stdio.h&gt;<br>// 分类 ———— 内部比较排序<br>// 数据结构 ——— 数组<br>// 最差时间复杂度 —- 每次选取的基准都是最大（或最小）的元素，导致每次只划分出了一个分区，需要进行n-1次划分才能结束递归，时间复杂度为O(n^2)<br>// 最优时间复杂度 —- 每次选取的基准都是中位数，这样每次都均匀的划分出两个分区，只需要logn次划分就能结束递归，时间复杂度为O(nlogn)<br>// 平均时间复杂度 —- O(nlogn)<br>// 所需辅助空间 —— 主要是递归造成的栈空间的使用(用来保存left和right等局部变量)，取决于递归树的深度，一般为O(logn)，最差为O(n)<br>// 稳定性 ———- 不稳定<br>void Swap(int A[], int i, int j)<br>{<br>    int temp = A[i];<br>    A[i] = A[j];<br>    A[j] = temp;<br>}<br>int Partition(int A[], int left, int right)  // 划分函数<br>{<br>    int pivot = A[right];               // 这里每次都选择最后一个元素作为基准<br>    int tail = left - 1;                // tail为小于基准的子数组最后一个元素的索引<br>    for (int i = left; i &lt; right; i++)  // 遍历基准以外的其他元素<br>    {<br>        if (A[i] &lt;= pivot)              // 把小于等于基准的元素放到前一个子数组末尾<br>        {<br>            Swap(A, ++tail, i);<br>        }<br>    }<br>    Swap(A, tail + 1, right);           // 最后把基准放到前一个子数组的后边，剩下的子数组既是大于基准的子数组<br>                                        // 该操作很有可能把后面元素的稳定性打乱，所以快速排序是不稳定的排序算法<br>    return tail + 1;                    // 返回基准的索引<br>}<br>void QuickSort(int A[], int left, int right)<br>{<br>    if (left &gt;= right)<br>        return;<br>    int pivot_index = Partition(A, left, right); // 基准的索引<br>    QuickSort(A, left, pivot_index - 1);<br>    QuickSort(A, pivot_index + 1, right);<br>}<br>int main()<br>{<br>    int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 }; // 从小到大快速排序<br>    int n = sizeof(A) / sizeof(int);<br>    QuickSort(A, 0, n - 1);<br>    printf(“快速排序结果：”);<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        printf(“%d “, A[i]);<br>    }<br>    printf(“\\n”);<br>    return 0;<br>}</p>\n<p>使用快速排序法对一列数字进行排序的过程：</p>\n<p>快速排序是不稳定的排序算法，不稳定发生在基准元素与A[tail+1]交换的时刻。<br>比如序列：{ 1, 3, 4, 2, 8, 9, 8, 7, 5 }，基准元素是5，一次划分操作后5要和第一个8进行交换，从而改变了两个元素8的相对次序。</p>\n<p>Java系统提供的Arrays.sort函数。对于基础类型，底层使用快速排序。对于非基础类型，底层使用归并排序。请问是为什么？<br>答：这是考虑到排序算法的稳定性。对于基础类型，相同值是无差别的，排序前后相同值的相对位置并不重要，所以选择更为高效的快速排序，尽管它是不稳定的排序算法；而对于非基础类型，排序前后相等实例的相对位置不宜改变，所以选择稳定的归并排序。 </p>\n"},{"title":"插入排序","date":"2018-04-16T15:20:40.000Z","_content":"插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌\n\n \n对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。\n插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。\n具体算法描述如下：\n        1. 从第一个元素开始，该元素可以认为已经被排序\n        2. 取出下一个元素，在已经排序的元素序列中从后向前扫描\n        3. 如果该元素（已排序）大于新元素，将该元素移到下一位置\n        4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置\n        5. 将新元素插入到该位置后\n        6. 重复步骤2~5\n插入排序的代码如下：\n\n#include <stdio.h>\n// 分类 ------------- 内部比较排序\n// 数据结构 ---------- 数组\n// 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)\n// 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)\n// 平均时间复杂度 ---- O(n^2)\n// 所需辅助空间 ------ O(1)\n// 稳定性 ------------ 稳定\nvoid InsertionSort(int A[], int n)\n{\n    for (int i = 1; i < n; i++)         // 类似抓扑克牌排序\n    {\n        int get = A[i];                 // 右手抓到一张扑克牌\n        int j = i - 1;                  // 拿在左手上的牌总是排序好的\n        while (j >= 0 && A[j] > get)    // 将抓到的牌与手牌从右向左进行比较\n        {\n            A[j + 1] = A[j];            // 如果该手牌比抓到的牌大，就将其右移\n            j--;\n        }\n        A[j + 1] = get; // 直到该手牌比抓到的牌小(或二者相等)，将抓到的牌插入到该手牌右边(相等元素的相对次序未变，所以插入排序是稳定的)\n    }\n}\nint main()\n{\n    int A[] = { 6, 5, 3, 1, 8, 7, 2, 4 };// 从小到大插入排序\n    int n = sizeof(A) / sizeof(int);\n    InsertionSort(A, n);\n    printf(\"插入排序结果：\");\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \", A[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \n 　　上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行插入排序的实现过程如下\n\n使用插入排序为一列数字进行排序的宏观过程：\n\n插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。\n \n \n插入排序的改进：二分插入排序\n \n对于插入排序，如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的次数，我们称为二分插入排序，代码如下：\n\n#include <stdio.h>\n// 分类 -------------- 内部比较排序\n// 数据结构 ---------- 数组\n// 最差时间复杂度 ---- O(n^2)\n// 最优时间复杂度 ---- O(nlogn)\n// 平均时间复杂度 ---- O(n^2)\n// 所需辅助空间 ------ O(1)\n// 稳定性 ------------ 稳定\nvoid InsertionSortDichotomy(int A[], int n)\n{\n    for (int i = 1; i < n; i++)\n    {\n        int get = A[i];                    // 右手抓到一张扑克牌\n        int left = 0;                    // 拿在左手上的牌总是排序好的，所以可以用二分法\n        int right = i - 1;                // 手牌左右边界进行初始化\n        while (left <= right)            // 采用二分法定位新牌的位置\n        {\n            int mid = (left + right) / 2;\n            if (A[mid] > get)\n                right = mid - 1;\n            else\n                left = mid + 1;\n        }\n        for (int j = i - 1; j >= left; j--)    // 将欲插入新牌位置右边的牌整体向右移动一个单位\n        {\n            A[j + 1] = A[j];\n        }\n        A[left] = get;                    // 将抓到的牌插入手牌\n    }\n}\nint main()\n{\n    int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 };// 从小到大二分插入排序\n    int n = sizeof(A) / sizeof(int);\n    InsertionSortDichotomy(A, n);\n    printf(\"二分插入排序结果：\");\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \", A[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \n当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。\n \n \n插入排序的更高效改进：希尔排序(Shell Sort)\n \n希尔排序，也叫递减增量排序，是插入排序的一种更高效的改进版本。希尔排序是不稳定的排序算法。\n希尔排序是基于插入排序的以下两点性质而提出改进方法的：\n        • 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率\n        • 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位\n希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。\n假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。\n希尔排序的代码如下：\n\n#include <stdio.h>  \n// 分类 -------------- 内部比较排序\n// 数据结构 ---------- 数组\n// 最差时间复杂度 ---- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)\n// 最优时间复杂度 ---- O(n)\n// 平均时间复杂度 ---- 根据步长序列的不同而不同。\n// 所需辅助空间 ------ O(1)\n// 稳定性 ------------ 不稳定\nvoid ShellSort(int A[], int n)\n{\n    int h = 0;\n    while (h <= n)                          // 生成初始增量\n    {\n        h = 3 * h + 1;\n    }\n    while (h >= 1)\n    {\n        for (int i = h; i < n; i++)\n        {\n            int j = i - h;\n            int get = A[i];\n            while (j >= 0 && A[j] > get)\n            {\n                A[j + h] = A[j];\n                j = j - h;\n            }\n            A[j + h] = get;\n        }\n        h = (h - 1) / 3;                    // 递减增量\n    }\n}\nint main()\n{\n    int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 };// 从小到大希尔排序\n    int n = sizeof(A) / sizeof(int);\n    ShellSort(A, n);\n    printf(\"希尔排序结果：\");\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \", A[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \n以23, 10, 4, 1的步长序列进行希尔排序：\n\n希尔排序是不稳定的排序算法，虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱。\n比如序列：{ 3, 5, 10, 8, 7, 2, 8, 1, 20, 6 }，h=2时分成两个子序列 { 3, 10, 7, 8, 20 } 和  { 5, 8, 2, 1, 6 } ，未排序之前第二个子序列中的8在前面，现在对两个子序列进行插入排序，得到 { 3, 7, 8, 10, 20 } 和 { 1, 2, 5, 6, 8 } ，即 { 3, 1, 7, 2, 8, 5, 10, 6, 20, 8 } ，两个8的相对次序发生了改变。\n","source":"_posts/插入排序.md","raw":"---\ntitle: 插入排序\ntags: \n- 算法排序\n- 基础知识\ncategories: \n- 基础知识\n- 算法排序\ndate: 2018-04-16 23:20:40\n---\n插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌\n\n \n对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。\n插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。\n具体算法描述如下：\n        1. 从第一个元素开始，该元素可以认为已经被排序\n        2. 取出下一个元素，在已经排序的元素序列中从后向前扫描\n        3. 如果该元素（已排序）大于新元素，将该元素移到下一位置\n        4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置\n        5. 将新元素插入到该位置后\n        6. 重复步骤2~5\n插入排序的代码如下：\n\n#include <stdio.h>\n// 分类 ------------- 内部比较排序\n// 数据结构 ---------- 数组\n// 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)\n// 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)\n// 平均时间复杂度 ---- O(n^2)\n// 所需辅助空间 ------ O(1)\n// 稳定性 ------------ 稳定\nvoid InsertionSort(int A[], int n)\n{\n    for (int i = 1; i < n; i++)         // 类似抓扑克牌排序\n    {\n        int get = A[i];                 // 右手抓到一张扑克牌\n        int j = i - 1;                  // 拿在左手上的牌总是排序好的\n        while (j >= 0 && A[j] > get)    // 将抓到的牌与手牌从右向左进行比较\n        {\n            A[j + 1] = A[j];            // 如果该手牌比抓到的牌大，就将其右移\n            j--;\n        }\n        A[j + 1] = get; // 直到该手牌比抓到的牌小(或二者相等)，将抓到的牌插入到该手牌右边(相等元素的相对次序未变，所以插入排序是稳定的)\n    }\n}\nint main()\n{\n    int A[] = { 6, 5, 3, 1, 8, 7, 2, 4 };// 从小到大插入排序\n    int n = sizeof(A) / sizeof(int);\n    InsertionSort(A, n);\n    printf(\"插入排序结果：\");\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \", A[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \n 　　上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行插入排序的实现过程如下\n\n使用插入排序为一列数字进行排序的宏观过程：\n\n插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。\n \n \n插入排序的改进：二分插入排序\n \n对于插入排序，如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的次数，我们称为二分插入排序，代码如下：\n\n#include <stdio.h>\n// 分类 -------------- 内部比较排序\n// 数据结构 ---------- 数组\n// 最差时间复杂度 ---- O(n^2)\n// 最优时间复杂度 ---- O(nlogn)\n// 平均时间复杂度 ---- O(n^2)\n// 所需辅助空间 ------ O(1)\n// 稳定性 ------------ 稳定\nvoid InsertionSortDichotomy(int A[], int n)\n{\n    for (int i = 1; i < n; i++)\n    {\n        int get = A[i];                    // 右手抓到一张扑克牌\n        int left = 0;                    // 拿在左手上的牌总是排序好的，所以可以用二分法\n        int right = i - 1;                // 手牌左右边界进行初始化\n        while (left <= right)            // 采用二分法定位新牌的位置\n        {\n            int mid = (left + right) / 2;\n            if (A[mid] > get)\n                right = mid - 1;\n            else\n                left = mid + 1;\n        }\n        for (int j = i - 1; j >= left; j--)    // 将欲插入新牌位置右边的牌整体向右移动一个单位\n        {\n            A[j + 1] = A[j];\n        }\n        A[left] = get;                    // 将抓到的牌插入手牌\n    }\n}\nint main()\n{\n    int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 };// 从小到大二分插入排序\n    int n = sizeof(A) / sizeof(int);\n    InsertionSortDichotomy(A, n);\n    printf(\"二分插入排序结果：\");\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \", A[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \n当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。\n \n \n插入排序的更高效改进：希尔排序(Shell Sort)\n \n希尔排序，也叫递减增量排序，是插入排序的一种更高效的改进版本。希尔排序是不稳定的排序算法。\n希尔排序是基于插入排序的以下两点性质而提出改进方法的：\n        • 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率\n        • 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位\n希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。\n假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。\n希尔排序的代码如下：\n\n#include <stdio.h>  \n// 分类 -------------- 内部比较排序\n// 数据结构 ---------- 数组\n// 最差时间复杂度 ---- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)\n// 最优时间复杂度 ---- O(n)\n// 平均时间复杂度 ---- 根据步长序列的不同而不同。\n// 所需辅助空间 ------ O(1)\n// 稳定性 ------------ 不稳定\nvoid ShellSort(int A[], int n)\n{\n    int h = 0;\n    while (h <= n)                          // 生成初始增量\n    {\n        h = 3 * h + 1;\n    }\n    while (h >= 1)\n    {\n        for (int i = h; i < n; i++)\n        {\n            int j = i - h;\n            int get = A[i];\n            while (j >= 0 && A[j] > get)\n            {\n                A[j + h] = A[j];\n                j = j - h;\n            }\n            A[j + h] = get;\n        }\n        h = (h - 1) / 3;                    // 递减增量\n    }\n}\nint main()\n{\n    int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 };// 从小到大希尔排序\n    int n = sizeof(A) / sizeof(int);\n    ShellSort(A, n);\n    printf(\"希尔排序结果：\");\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \", A[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \n以23, 10, 4, 1的步长序列进行希尔排序：\n\n希尔排序是不稳定的排序算法，虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱。\n比如序列：{ 3, 5, 10, 8, 7, 2, 8, 1, 20, 6 }，h=2时分成两个子序列 { 3, 10, 7, 8, 20 } 和  { 5, 8, 2, 1, 6 } ，未排序之前第二个子序列中的8在前面，现在对两个子序列进行插入排序，得到 { 3, 7, 8, 10, 20 } 和 { 1, 2, 5, 6, 8 } ，即 { 3, 1, 7, 2, 8, 5, 10, 6, 20, 8 } ，两个8的相对次序发生了改变。\n","slug":"插入排序","published":1,"updated":"2018-04-29T06:42:47.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgkim7zw000jiku77ui53r76","content":"<p>插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌</p>\n<p>对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。<br>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。<br>具体算法描述如下：</p>\n<pre><code>1. 从第一个元素开始，该元素可以认为已经被排序\n2. 取出下一个元素，在已经排序的元素序列中从后向前扫描\n3. 如果该元素（已排序）大于新元素，将该元素移到下一位置\n4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置\n5. 将新元素插入到该位置后\n6. 重复步骤2~5\n</code></pre><p>插入排序的代码如下：</p>\n<p>#include &lt;stdio.h&gt;<br>// 分类 ————- 内部比较排序<br>// 数据结构 ———- 数组<br>// 最差时间复杂度 —- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)<br>// 最优时间复杂度 —- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)<br>// 平均时间复杂度 —- O(n^2)<br>// 所需辅助空间 —— O(1)<br>// 稳定性 ———— 稳定<br>void InsertionSort(int A[], int n)<br>{<br>    for (int i = 1; i &lt; n; i++)         // 类似抓扑克牌排序<br>    {<br>        int get = A[i];                 // 右手抓到一张扑克牌<br>        int j = i - 1;                  // 拿在左手上的牌总是排序好的<br>        while (j &gt;= 0 &amp;&amp; A[j] &gt; get)    // 将抓到的牌与手牌从右向左进行比较<br>        {<br>            A[j + 1] = A[j];            // 如果该手牌比抓到的牌大，就将其右移<br>            j–;<br>        }<br>        A[j + 1] = get; // 直到该手牌比抓到的牌小(或二者相等)，将抓到的牌插入到该手牌右边(相等元素的相对次序未变，所以插入排序是稳定的)<br>    }<br>}<br>int main()<br>{<br>    int A[] = { 6, 5, 3, 1, 8, 7, 2, 4 };// 从小到大插入排序<br>    int n = sizeof(A) / sizeof(int);<br>    InsertionSort(A, n);<br>    printf(“插入排序结果：”);<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        printf(“%d “, A[i]);<br>    }<br>    printf(“\\n”);<br>    return 0;<br>}</p>\n<p> 　　上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行插入排序的实现过程如下</p>\n<p>使用插入排序为一列数字进行排序的宏观过程：</p>\n<p>插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。</p>\n<p>插入排序的改进：二分插入排序</p>\n<p>对于插入排序，如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的次数，我们称为二分插入排序，代码如下：</p>\n<p>#include &lt;stdio.h&gt;<br>// 分类 ————– 内部比较排序<br>// 数据结构 ———- 数组<br>// 最差时间复杂度 —- O(n^2)<br>// 最优时间复杂度 —- O(nlogn)<br>// 平均时间复杂度 —- O(n^2)<br>// 所需辅助空间 —— O(1)<br>// 稳定性 ———— 稳定<br>void InsertionSortDichotomy(int A[], int n)<br>{<br>    for (int i = 1; i &lt; n; i++)<br>    {<br>        int get = A[i];                    // 右手抓到一张扑克牌<br>        int left = 0;                    // 拿在左手上的牌总是排序好的，所以可以用二分法<br>        int right = i - 1;                // 手牌左右边界进行初始化<br>        while (left &lt;= right)            // 采用二分法定位新牌的位置<br>        {<br>            int mid = (left + right) / 2;<br>            if (A[mid] &gt; get)<br>                right = mid - 1;<br>            else<br>                left = mid + 1;<br>        }<br>        for (int j = i - 1; j &gt;= left; j–)    // 将欲插入新牌位置右边的牌整体向右移动一个单位<br>        {<br>            A[j + 1] = A[j];<br>        }<br>        A[left] = get;                    // 将抓到的牌插入手牌<br>    }<br>}<br>int main()<br>{<br>    int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 };// 从小到大二分插入排序<br>    int n = sizeof(A) / sizeof(int);<br>    InsertionSortDichotomy(A, n);<br>    printf(“二分插入排序结果：”);<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        printf(“%d “, A[i]);<br>    }<br>    printf(“\\n”);<br>    return 0;<br>}</p>\n<p>当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。</p>\n<p>插入排序的更高效改进：希尔排序(Shell Sort)</p>\n<p>希尔排序，也叫递减增量排序，是插入排序的一种更高效的改进版本。希尔排序是不稳定的排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br>        • 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率<br>        • 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位<br>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。<br>假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。<br>希尔排序的代码如下：</p>\n<p>#include &lt;stdio.h&gt;<br>// 分类 ————– 内部比较排序<br>// 数据结构 ———- 数组<br>// 最差时间复杂度 —- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)<br>// 最优时间复杂度 —- O(n)<br>// 平均时间复杂度 —- 根据步长序列的不同而不同。<br>// 所需辅助空间 —— O(1)<br>// 稳定性 ———— 不稳定<br>void ShellSort(int A[], int n)<br>{<br>    int h = 0;<br>    while (h &lt;= n)                          // 生成初始增量<br>    {<br>        h = 3 * h + 1;<br>    }<br>    while (h &gt;= 1)<br>    {<br>        for (int i = h; i &lt; n; i++)<br>        {<br>            int j = i - h;<br>            int get = A[i];<br>            while (j &gt;= 0 &amp;&amp; A[j] &gt; get)<br>            {<br>                A[j + h] = A[j];<br>                j = j - h;<br>            }<br>            A[j + h] = get;<br>        }<br>        h = (h - 1) / 3;                    // 递减增量<br>    }<br>}<br>int main()<br>{<br>    int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 };// 从小到大希尔排序<br>    int n = sizeof(A) / sizeof(int);<br>    ShellSort(A, n);<br>    printf(“希尔排序结果：”);<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        printf(“%d “, A[i]);<br>    }<br>    printf(“\\n”);<br>    return 0;<br>}</p>\n<p>以23, 10, 4, 1的步长序列进行希尔排序：</p>\n<p>希尔排序是不稳定的排序算法，虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱。<br>比如序列：{ 3, 5, 10, 8, 7, 2, 8, 1, 20, 6 }，h=2时分成两个子序列 { 3, 10, 7, 8, 20 } 和  { 5, 8, 2, 1, 6 } ，未排序之前第二个子序列中的8在前面，现在对两个子序列进行插入排序，得到 { 3, 7, 8, 10, 20 } 和 { 1, 2, 5, 6, 8 } ，即 { 3, 1, 7, 2, 8, 5, 10, 6, 20, 8 } ，两个8的相对次序发生了改变。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌</p>\n<p>对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。<br>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。<br>具体算法描述如下：</p>\n<pre><code>1. 从第一个元素开始，该元素可以认为已经被排序\n2. 取出下一个元素，在已经排序的元素序列中从后向前扫描\n3. 如果该元素（已排序）大于新元素，将该元素移到下一位置\n4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置\n5. 将新元素插入到该位置后\n6. 重复步骤2~5\n</code></pre><p>插入排序的代码如下：</p>\n<p>#include &lt;stdio.h&gt;<br>// 分类 ————- 内部比较排序<br>// 数据结构 ———- 数组<br>// 最差时间复杂度 —- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)<br>// 最优时间复杂度 —- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)<br>// 平均时间复杂度 —- O(n^2)<br>// 所需辅助空间 —— O(1)<br>// 稳定性 ———— 稳定<br>void InsertionSort(int A[], int n)<br>{<br>    for (int i = 1; i &lt; n; i++)         // 类似抓扑克牌排序<br>    {<br>        int get = A[i];                 // 右手抓到一张扑克牌<br>        int j = i - 1;                  // 拿在左手上的牌总是排序好的<br>        while (j &gt;= 0 &amp;&amp; A[j] &gt; get)    // 将抓到的牌与手牌从右向左进行比较<br>        {<br>            A[j + 1] = A[j];            // 如果该手牌比抓到的牌大，就将其右移<br>            j–;<br>        }<br>        A[j + 1] = get; // 直到该手牌比抓到的牌小(或二者相等)，将抓到的牌插入到该手牌右边(相等元素的相对次序未变，所以插入排序是稳定的)<br>    }<br>}<br>int main()<br>{<br>    int A[] = { 6, 5, 3, 1, 8, 7, 2, 4 };// 从小到大插入排序<br>    int n = sizeof(A) / sizeof(int);<br>    InsertionSort(A, n);<br>    printf(“插入排序结果：”);<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        printf(“%d “, A[i]);<br>    }<br>    printf(“\\n”);<br>    return 0;<br>}</p>\n<p> 　　上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行插入排序的实现过程如下</p>\n<p>使用插入排序为一列数字进行排序的宏观过程：</p>\n<p>插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。</p>\n<p>插入排序的改进：二分插入排序</p>\n<p>对于插入排序，如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的次数，我们称为二分插入排序，代码如下：</p>\n<p>#include &lt;stdio.h&gt;<br>// 分类 ————– 内部比较排序<br>// 数据结构 ———- 数组<br>// 最差时间复杂度 —- O(n^2)<br>// 最优时间复杂度 —- O(nlogn)<br>// 平均时间复杂度 —- O(n^2)<br>// 所需辅助空间 —— O(1)<br>// 稳定性 ———— 稳定<br>void InsertionSortDichotomy(int A[], int n)<br>{<br>    for (int i = 1; i &lt; n; i++)<br>    {<br>        int get = A[i];                    // 右手抓到一张扑克牌<br>        int left = 0;                    // 拿在左手上的牌总是排序好的，所以可以用二分法<br>        int right = i - 1;                // 手牌左右边界进行初始化<br>        while (left &lt;= right)            // 采用二分法定位新牌的位置<br>        {<br>            int mid = (left + right) / 2;<br>            if (A[mid] &gt; get)<br>                right = mid - 1;<br>            else<br>                left = mid + 1;<br>        }<br>        for (int j = i - 1; j &gt;= left; j–)    // 将欲插入新牌位置右边的牌整体向右移动一个单位<br>        {<br>            A[j + 1] = A[j];<br>        }<br>        A[left] = get;                    // 将抓到的牌插入手牌<br>    }<br>}<br>int main()<br>{<br>    int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 };// 从小到大二分插入排序<br>    int n = sizeof(A) / sizeof(int);<br>    InsertionSortDichotomy(A, n);<br>    printf(“二分插入排序结果：”);<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        printf(“%d “, A[i]);<br>    }<br>    printf(“\\n”);<br>    return 0;<br>}</p>\n<p>当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。</p>\n<p>插入排序的更高效改进：希尔排序(Shell Sort)</p>\n<p>希尔排序，也叫递减增量排序，是插入排序的一种更高效的改进版本。希尔排序是不稳定的排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：<br>        • 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率<br>        • 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位<br>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。<br>假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。<br>希尔排序的代码如下：</p>\n<p>#include &lt;stdio.h&gt;<br>// 分类 ————– 内部比较排序<br>// 数据结构 ———- 数组<br>// 最差时间复杂度 —- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)<br>// 最优时间复杂度 —- O(n)<br>// 平均时间复杂度 —- 根据步长序列的不同而不同。<br>// 所需辅助空间 —— O(1)<br>// 稳定性 ———— 不稳定<br>void ShellSort(int A[], int n)<br>{<br>    int h = 0;<br>    while (h &lt;= n)                          // 生成初始增量<br>    {<br>        h = 3 * h + 1;<br>    }<br>    while (h &gt;= 1)<br>    {<br>        for (int i = h; i &lt; n; i++)<br>        {<br>            int j = i - h;<br>            int get = A[i];<br>            while (j &gt;= 0 &amp;&amp; A[j] &gt; get)<br>            {<br>                A[j + h] = A[j];<br>                j = j - h;<br>            }<br>            A[j + h] = get;<br>        }<br>        h = (h - 1) / 3;                    // 递减增量<br>    }<br>}<br>int main()<br>{<br>    int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 };// 从小到大希尔排序<br>    int n = sizeof(A) / sizeof(int);<br>    ShellSort(A, n);<br>    printf(“希尔排序结果：”);<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        printf(“%d “, A[i]);<br>    }<br>    printf(“\\n”);<br>    return 0;<br>}</p>\n<p>以23, 10, 4, 1的步长序列进行希尔排序：</p>\n<p>希尔排序是不稳定的排序算法，虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱。<br>比如序列：{ 3, 5, 10, 8, 7, 2, 8, 1, 20, 6 }，h=2时分成两个子序列 { 3, 10, 7, 8, 20 } 和  { 5, 8, 2, 1, 6 } ，未排序之前第二个子序列中的8在前面，现在对两个子序列进行插入排序，得到 { 3, 7, 8, 10, 20 } 和 { 1, 2, 5, 6, 8 } ，即 { 3, 1, 7, 2, 8, 5, 10, 6, 20, 8 } ，两个8的相对次序发生了改变。</p>\n"},{"title":"桶排序","date":"2018-04-16T15:20:40.000Z","_content":"桶排序也叫箱排序。工作的原理是将数组元素映射到有限数量个桶里，利用计数排序可以定位桶的边界，每个桶再各自进行桶内排序（使用其它排序算法或以递归方式继续使用桶排序）。\n桶排序的实现代码如下：\n\n#include<iostream>\nusing namespace std;\n// 分类 ------------- 内部非比较排序\n// 数据结构 --------- 数组\n// 最差时间复杂度 ---- O(nlogn)或O(n^2)，只有一个桶，取决于桶内排序方式\n// 最优时间复杂度 ---- O(n)，每个元素占一个桶\n// 平均时间复杂度 ---- O(n)，保证各个桶内元素个数均匀即可\n// 所需辅助空间 ------ O(n + bn)\n// 稳定性 ----------- 稳定\n/* 本程序用数组模拟桶 */\nconst int bn = 5;    // 这里排序[0,49]的元素，使用5个桶就够了，也可以根据输入动态确定桶的数量\nint C[bn];           // 计数数组，存放桶的边界信息\nvoid InsertionSort(int A[], int left, int right)\n{\n    for (int i = left + 1; i <= right; i++)  // 从第二张牌开始抓，直到最后一张牌\n    {\n        int get = A[i];\n        int j = i - 1;\n        while (j >= left && A[j] > get)\n        {\n            A[j + 1] = A[j];\n            j--;\n        }\n        A[j + 1] = get;\n    }\n}\nint MapToBucket(int x)\n{\n    return x / 10;    // 映射函数f(x)，作用相当于快排中的Partition，把大量数据分割成基本有序的数据块\n}\nvoid CountingSort(int A[], int n)\n{\n    for (int i = 0; i < bn; i++)\n    {\n        C[i] = 0;\n    }\n    for (int i = 0; i < n; i++)     // 使C[i]保存着i号桶中元素的个数\n    {\n        C[MapToBucket(A[i])]++;\n    }\n    for (int i = 1; i < bn; i++)    // 定位桶边界：初始时，C[i]-1为i号桶最后一个元素的位置\n    {\n        C[i] = C[i] + C[i - 1];\n    }\n    int *B = (int *)malloc((n) * sizeof(int));\n    for (int i = n - 1; i >= 0; i--)// 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)\n    {\n        int b = MapToBucket(A[i]);  // 元素A[i]位于b号桶\n        B[--C[b]] = A[i];           // 把每个元素A[i]放到它在输出数组B中的正确位置上\n                                    // 桶的边界被更新：C[b]为b号桶第一个元素的位置\n    }\n    for (int i = 0; i < n; i++)\n    {\n        A[i] = B[i];\n    }\n    free(B);\n}\nvoid BucketSort(int A[], int n)\n{\n    CountingSort(A, n);          // 利用计数排序确定各个桶的边界（分桶）\n    for (int i = 0; i < bn; i++) // 对每一个桶中的元素应用插入排序\n    {\n        int left = C[i];         // C[i]为i号桶第一个元素的位置\n        int right = (i == bn - 1 ? n - 1 : C[i + 1] - 1);// C[i+1]-1为i号桶最后一个元素的位置\n        if (left < right)        // 对元素个数大于1的桶进行桶内插入排序\n            InsertionSort(A, left, right);\n    }\n}\nint main()\n{\n    int A[] = { 29, 25, 3, 49, 9, 37, 21, 43 };// 针对桶排序设计的输入\n    int n = sizeof(A) / sizeof(int);\n    BucketSort(A, n);\n    printf(\"桶排序结果：\");\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \", A[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \n 　　下图给出了对{ 29, 25, 3, 49, 9, 37, 21, 43 }进行桶排序的简单演示过程\n\n \n桶排序不是比较排序，不受到O(nlogn)下限的影响，它是鸽巢排序的一种归纳结果，当所要排序的数组值分散均匀的时候，桶排序拥有线性的时间复杂度。\n","source":"_posts/桶排序.md","raw":"---\ntitle: 桶排序\ntags: \n- 算法排序\n- 基础知识\ncategories: \n- 基础知识\n- 算法排序\ndate: 2018-04-16 23:20:40\n---\n桶排序也叫箱排序。工作的原理是将数组元素映射到有限数量个桶里，利用计数排序可以定位桶的边界，每个桶再各自进行桶内排序（使用其它排序算法或以递归方式继续使用桶排序）。\n桶排序的实现代码如下：\n\n#include<iostream>\nusing namespace std;\n// 分类 ------------- 内部非比较排序\n// 数据结构 --------- 数组\n// 最差时间复杂度 ---- O(nlogn)或O(n^2)，只有一个桶，取决于桶内排序方式\n// 最优时间复杂度 ---- O(n)，每个元素占一个桶\n// 平均时间复杂度 ---- O(n)，保证各个桶内元素个数均匀即可\n// 所需辅助空间 ------ O(n + bn)\n// 稳定性 ----------- 稳定\n/* 本程序用数组模拟桶 */\nconst int bn = 5;    // 这里排序[0,49]的元素，使用5个桶就够了，也可以根据输入动态确定桶的数量\nint C[bn];           // 计数数组，存放桶的边界信息\nvoid InsertionSort(int A[], int left, int right)\n{\n    for (int i = left + 1; i <= right; i++)  // 从第二张牌开始抓，直到最后一张牌\n    {\n        int get = A[i];\n        int j = i - 1;\n        while (j >= left && A[j] > get)\n        {\n            A[j + 1] = A[j];\n            j--;\n        }\n        A[j + 1] = get;\n    }\n}\nint MapToBucket(int x)\n{\n    return x / 10;    // 映射函数f(x)，作用相当于快排中的Partition，把大量数据分割成基本有序的数据块\n}\nvoid CountingSort(int A[], int n)\n{\n    for (int i = 0; i < bn; i++)\n    {\n        C[i] = 0;\n    }\n    for (int i = 0; i < n; i++)     // 使C[i]保存着i号桶中元素的个数\n    {\n        C[MapToBucket(A[i])]++;\n    }\n    for (int i = 1; i < bn; i++)    // 定位桶边界：初始时，C[i]-1为i号桶最后一个元素的位置\n    {\n        C[i] = C[i] + C[i - 1];\n    }\n    int *B = (int *)malloc((n) * sizeof(int));\n    for (int i = n - 1; i >= 0; i--)// 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)\n    {\n        int b = MapToBucket(A[i]);  // 元素A[i]位于b号桶\n        B[--C[b]] = A[i];           // 把每个元素A[i]放到它在输出数组B中的正确位置上\n                                    // 桶的边界被更新：C[b]为b号桶第一个元素的位置\n    }\n    for (int i = 0; i < n; i++)\n    {\n        A[i] = B[i];\n    }\n    free(B);\n}\nvoid BucketSort(int A[], int n)\n{\n    CountingSort(A, n);          // 利用计数排序确定各个桶的边界（分桶）\n    for (int i = 0; i < bn; i++) // 对每一个桶中的元素应用插入排序\n    {\n        int left = C[i];         // C[i]为i号桶第一个元素的位置\n        int right = (i == bn - 1 ? n - 1 : C[i + 1] - 1);// C[i+1]-1为i号桶最后一个元素的位置\n        if (left < right)        // 对元素个数大于1的桶进行桶内插入排序\n            InsertionSort(A, left, right);\n    }\n}\nint main()\n{\n    int A[] = { 29, 25, 3, 49, 9, 37, 21, 43 };// 针对桶排序设计的输入\n    int n = sizeof(A) / sizeof(int);\n    BucketSort(A, n);\n    printf(\"桶排序结果：\");\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \", A[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \n 　　下图给出了对{ 29, 25, 3, 49, 9, 37, 21, 43 }进行桶排序的简单演示过程\n\n \n桶排序不是比较排序，不受到O(nlogn)下限的影响，它是鸽巢排序的一种归纳结果，当所要排序的数组值分散均匀的时候，桶排序拥有线性的时间复杂度。\n","slug":"桶排序","published":1,"updated":"2018-04-29T06:42:47.084Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgkim801000kiku7x69ugjlb","content":"<p>桶排序也叫箱排序。工作的原理是将数组元素映射到有限数量个桶里，利用计数排序可以定位桶的边界，每个桶再各自进行桶内排序（使用其它排序算法或以递归方式继续使用桶排序）。<br>桶排序的实现代码如下：</p>\n<p>#include<iostream><br>using namespace std;<br>// 分类 ————- 内部非比较排序<br>// 数据结构 ——— 数组<br>// 最差时间复杂度 —- O(nlogn)或O(n^2)，只有一个桶，取决于桶内排序方式<br>// 最优时间复杂度 —- O(n)，每个元素占一个桶<br>// 平均时间复杂度 —- O(n)，保证各个桶内元素个数均匀即可<br>// 所需辅助空间 —— O(n + bn)<br>// 稳定性 ———– 稳定<br>/<em> 本程序用数组模拟桶 </em>/<br>const int bn = 5;    // 这里排序[0,49]的元素，使用5个桶就够了，也可以根据输入动态确定桶的数量<br>int C[bn];           // 计数数组，存放桶的边界信息<br>void InsertionSort(int A[], int left, int right)<br>{<br>    for (int i = left + 1; i &lt;= right; i++)  // 从第二张牌开始抓，直到最后一张牌<br>    {<br>        int get = A[i];<br>        int j = i - 1;<br>        while (j &gt;= left &amp;&amp; A[j] &gt; get)<br>        {<br>            A[j + 1] = A[j];<br>            j–;<br>        }<br>        A[j + 1] = get;<br>    }<br>}<br>int MapToBucket(int x)<br>{<br>    return x / 10;    // 映射函数f(x)，作用相当于快排中的Partition，把大量数据分割成基本有序的数据块<br>}<br>void CountingSort(int A[], int n)<br>{<br>    for (int i = 0; i &lt; bn; i++)<br>    {<br>        C[i] = 0;<br>    }<br>    for (int i = 0; i &lt; n; i++)     // 使C[i]保存着i号桶中元素的个数<br>    {<br>        C[MapToBucket(A[i])]++;<br>    }<br>    for (int i = 1; i &lt; bn; i++)    // 定位桶边界：初始时，C[i]-1为i号桶最后一个元素的位置<br>    {<br>        C[i] = C[i] + C[i - 1];<br>    }<br>    int <em>B = (int </em>)malloc((n) * sizeof(int));<br>    for (int i = n - 1; i &gt;= 0; i–)// 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)<br>    {<br>        int b = MapToBucket(A[i]);  // 元素A[i]位于b号桶<br>        B[–C[b]] = A[i];           // 把每个元素A[i]放到它在输出数组B中的正确位置上<br>                                    // 桶的边界被更新：C[b]为b号桶第一个元素的位置<br>    }<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        A[i] = B[i];<br>    }<br>    free(B);<br>}<br>void BucketSort(int A[], int n)<br>{<br>    CountingSort(A, n);          // 利用计数排序确定各个桶的边界（分桶）<br>    for (int i = 0; i &lt; bn; i++) // 对每一个桶中的元素应用插入排序<br>    {<br>        int left = C[i];         // C[i]为i号桶第一个元素的位置<br>        int right = (i == bn - 1 ? n - 1 : C[i + 1] - 1);// C[i+1]-1为i号桶最后一个元素的位置<br>        if (left &lt; right)        // 对元素个数大于1的桶进行桶内插入排序<br>            InsertionSort(A, left, right);<br>    }<br>}<br>int main()<br>{<br>    int A[] = { 29, 25, 3, 49, 9, 37, 21, 43 };// 针对桶排序设计的输入<br>    int n = sizeof(A) / sizeof(int);<br>    BucketSort(A, n);<br>    printf(“桶排序结果：”);<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        printf(“%d “, A[i]);<br>    }<br>    printf(“\\n”);<br>    return 0;<br>}</iostream></p>\n<p> 　　下图给出了对{ 29, 25, 3, 49, 9, 37, 21, 43 }进行桶排序的简单演示过程</p>\n<p>桶排序不是比较排序，不受到O(nlogn)下限的影响，它是鸽巢排序的一种归纳结果，当所要排序的数组值分散均匀的时候，桶排序拥有线性的时间复杂度。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>桶排序也叫箱排序。工作的原理是将数组元素映射到有限数量个桶里，利用计数排序可以定位桶的边界，每个桶再各自进行桶内排序（使用其它排序算法或以递归方式继续使用桶排序）。<br>桶排序的实现代码如下：</p>\n<p>#include<iostream><br>using namespace std;<br>// 分类 ————- 内部非比较排序<br>// 数据结构 ——— 数组<br>// 最差时间复杂度 —- O(nlogn)或O(n^2)，只有一个桶，取决于桶内排序方式<br>// 最优时间复杂度 —- O(n)，每个元素占一个桶<br>// 平均时间复杂度 —- O(n)，保证各个桶内元素个数均匀即可<br>// 所需辅助空间 —— O(n + bn)<br>// 稳定性 ———– 稳定<br>/<em> 本程序用数组模拟桶 </em>/<br>const int bn = 5;    // 这里排序[0,49]的元素，使用5个桶就够了，也可以根据输入动态确定桶的数量<br>int C[bn];           // 计数数组，存放桶的边界信息<br>void InsertionSort(int A[], int left, int right)<br>{<br>    for (int i = left + 1; i &lt;= right; i++)  // 从第二张牌开始抓，直到最后一张牌<br>    {<br>        int get = A[i];<br>        int j = i - 1;<br>        while (j &gt;= left &amp;&amp; A[j] &gt; get)<br>        {<br>            A[j + 1] = A[j];<br>            j–;<br>        }<br>        A[j + 1] = get;<br>    }<br>}<br>int MapToBucket(int x)<br>{<br>    return x / 10;    // 映射函数f(x)，作用相当于快排中的Partition，把大量数据分割成基本有序的数据块<br>}<br>void CountingSort(int A[], int n)<br>{<br>    for (int i = 0; i &lt; bn; i++)<br>    {<br>        C[i] = 0;<br>    }<br>    for (int i = 0; i &lt; n; i++)     // 使C[i]保存着i号桶中元素的个数<br>    {<br>        C[MapToBucket(A[i])]++;<br>    }<br>    for (int i = 1; i &lt; bn; i++)    // 定位桶边界：初始时，C[i]-1为i号桶最后一个元素的位置<br>    {<br>        C[i] = C[i] + C[i - 1];<br>    }<br>    int <em>B = (int </em>)malloc((n) * sizeof(int));<br>    for (int i = n - 1; i &gt;= 0; i–)// 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)<br>    {<br>        int b = MapToBucket(A[i]);  // 元素A[i]位于b号桶<br>        B[–C[b]] = A[i];           // 把每个元素A[i]放到它在输出数组B中的正确位置上<br>                                    // 桶的边界被更新：C[b]为b号桶第一个元素的位置<br>    }<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        A[i] = B[i];<br>    }<br>    free(B);<br>}<br>void BucketSort(int A[], int n)<br>{<br>    CountingSort(A, n);          // 利用计数排序确定各个桶的边界（分桶）<br>    for (int i = 0; i &lt; bn; i++) // 对每一个桶中的元素应用插入排序<br>    {<br>        int left = C[i];         // C[i]为i号桶第一个元素的位置<br>        int right = (i == bn - 1 ? n - 1 : C[i + 1] - 1);// C[i+1]-1为i号桶最后一个元素的位置<br>        if (left &lt; right)        // 对元素个数大于1的桶进行桶内插入排序<br>            InsertionSort(A, left, right);<br>    }<br>}<br>int main()<br>{<br>    int A[] = { 29, 25, 3, 49, 9, 37, 21, 43 };// 针对桶排序设计的输入<br>    int n = sizeof(A) / sizeof(int);<br>    BucketSort(A, n);<br>    printf(“桶排序结果：”);<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        printf(“%d “, A[i]);<br>    }<br>    printf(“\\n”);<br>    return 0;<br>}</iostream></p>\n<p> 　　下图给出了对{ 29, 25, 3, 49, 9, 37, 21, 43 }进行桶排序的简单演示过程</p>\n<p>桶排序不是比较排序，不受到O(nlogn)下限的影响，它是鸽巢排序的一种归纳结果，当所要排序的数组值分散均匀的时候，桶排序拥有线性的时间复杂度。</p>\n"},{"title":"qqqqqqqqqqqggggggggggggqqqqqqqqqqqq","date":"2018-04-16T15:20:40.000Z","_content":"\n\n# ggggggggggggggggg\n## 小标题1\n1. 打开vmware workstationsgggggggggggggg，出现如下界面，选择`自定义（高级）`选项，下一步继续：\n{% asset_img 1.jpg [选择操作系统镜像] %}\n\n2. 打开vmware workstations，gggggggggggggg，出现如下界面，选择`自定义（高级）`选项，下一步继续：\n{% asset_img 1.jpg [选择操作系统镜像] %}\n\n\n# 设置CentOS参数\n1. 打开vmware workstations，gggggggggggggggggggggg，出现如下界面，选择`自定义（高级）`选项，下一步继续：\n{% asset_img 1.jpg [选择操作系统镜像] %}\n","source":"_posts/虽yi.md","raw":"---\ntitle: qqqqqqqqqqqggggggggggggqqqqqqqqqqqq\ntags: \n- 工具安装\n- 操作系统\ncategories: \n- 技术分享\n- 工具安装\ndate: 2018-04-16 23:20:40\n---\n\n\n# ggggggggggggggggg\n## 小标题1\n1. 打开vmware workstationsgggggggggggggg，出现如下界面，选择`自定义（高级）`选项，下一步继续：\n{% asset_img 1.jpg [选择操作系统镜像] %}\n\n2. 打开vmware workstations，gggggggggggggg，出现如下界面，选择`自定义（高级）`选项，下一步继续：\n{% asset_img 1.jpg [选择操作系统镜像] %}\n\n\n# 设置CentOS参数\n1. 打开vmware workstations，gggggggggggggggggggggg，出现如下界面，选择`自定义（高级）`选项，下一步继续：\n{% asset_img 1.jpg [选择操作系统镜像] %}\n","slug":"虽yi","published":1,"updated":"2018-04-29T06:42:47.103Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgkim808000oiku7qaxc56ao","content":"<h1 id=\"ggggggggggggggggg\"><a href=\"#ggggggggggggggggg\" class=\"headerlink\" title=\"ggggggggggggggggg\"></a>ggggggggggggggggg</h1><h2 id=\"小标题1\"><a href=\"#小标题1\" class=\"headerlink\" title=\"小标题1\"></a>小标题1</h2><ol>\n<li><p>打开vmware workstationsgggggggggggggg，出现如下界面，选择<code>自定义（高级）</code>选项，下一步继续：</p>\n\n</li>\n<li><p>打开vmware workstations，gggggggggggggg，出现如下界面，选择<code>自定义（高级）</code>选项，下一步继续：</p>\n\n</li>\n</ol>\n<h1 id=\"设置CentOS参数\"><a href=\"#设置CentOS参数\" class=\"headerlink\" title=\"设置CentOS参数\"></a>设置CentOS参数</h1><ol>\n<li>打开vmware workstations，gggggggggggggggggggggg，出现如下界面，选择<code>自定义（高级）</code>选项，下一步继续：\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ggggggggggggggggg\"><a href=\"#ggggggggggggggggg\" class=\"headerlink\" title=\"ggggggggggggggggg\"></a>ggggggggggggggggg</h1><h2 id=\"小标题1\"><a href=\"#小标题1\" class=\"headerlink\" title=\"小标题1\"></a>小标题1</h2><ol>\n<li><p>打开vmware workstationsgggggggggggggg，出现如下界面，选择<code>自定义（高级）</code>选项，下一步继续：</p>\n\n</li>\n<li><p>打开vmware workstations，gggggggggggggg，出现如下界面，选择<code>自定义（高级）</code>选项，下一步继续：</p>\n\n</li>\n</ol>\n<h1 id=\"设置CentOS参数\"><a href=\"#设置CentOS参数\" class=\"headerlink\" title=\"设置CentOS参数\"></a>设置CentOS参数</h1><ol>\n<li>打开vmware workstations，gggggggggggggggggggggg，出现如下界面，选择<code>自定义（高级）</code>选项，下一步继续：\n</li>\n</ol>\n"},{"title":"虚拟机安装CentOS教程","date":"2018-04-16T15:20:40.000Z","_content":"\n\n# 设置虚拟机参数\n## 小标题1\n1. 打开vmware workstations，`文件->新建虚拟机`，出现如下界面，选择`自定义（高级）`选项，下一步继续：\n{% asset_img 1.jpg [选择操作系统镜像] %}\n\n2. 打开vmware workstations，`文件->新建虚拟机`，出现如下界面，选择`自定义（高级）`选项，下一步继续：\n{% asset_img 1.jpg [选择操作系统镜像] %}\n\n\n# 设置CentOS参数\n1. 打开vmware workstations，`文件->新建虚拟机`，出现如下界面，选择`自定义（高级）`选项，下一步继续：\n{% asset_img 1.jpg [选择操作系统镜像] %}\n","source":"_posts/虚拟机安装CentOS教程.md","raw":"---\ntitle: 虚拟机安装CentOS教程\ntags: \n- 工具安装\n- 操作系统\ncategories: \n- 技术分享\n- 工具安装\ndate: 2018-04-16 23:20:40\n---\n\n\n# 设置虚拟机参数\n## 小标题1\n1. 打开vmware workstations，`文件->新建虚拟机`，出现如下界面，选择`自定义（高级）`选项，下一步继续：\n{% asset_img 1.jpg [选择操作系统镜像] %}\n\n2. 打开vmware workstations，`文件->新建虚拟机`，出现如下界面，选择`自定义（高级）`选项，下一步继续：\n{% asset_img 1.jpg [选择操作系统镜像] %}\n\n\n# 设置CentOS参数\n1. 打开vmware workstations，`文件->新建虚拟机`，出现如下界面，选择`自定义（高级）`选项，下一步继续：\n{% asset_img 1.jpg [选择操作系统镜像] %}\n","slug":"虚拟机安装CentOS教程","published":1,"updated":"2018-04-29T06:42:47.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgkim80d000riku76irl46rz","content":"<h1 id=\"设置虚拟机参数\"><a href=\"#设置虚拟机参数\" class=\"headerlink\" title=\"设置虚拟机参数\"></a>设置虚拟机参数</h1><h2 id=\"小标题1\"><a href=\"#小标题1\" class=\"headerlink\" title=\"小标题1\"></a>小标题1</h2><ol>\n<li><p>打开vmware workstations，<code>文件-&gt;新建虚拟机</code>，出现如下界面，选择<code>自定义（高级）</code>选项，下一步继续：</p>\n<img src=\"/2018/04/16/虚拟机安装CentOS教程/1.jpg\" title=\"[选择操作系统镜像]\">\n</li>\n<li><p>打开vmware workstations，<code>文件-&gt;新建虚拟机</code>，出现如下界面，选择<code>自定义（高级）</code>选项，下一步继续：</p>\n<img src=\"/2018/04/16/虚拟机安装CentOS教程/1.jpg\" title=\"[选择操作系统镜像]\">\n</li>\n</ol>\n<h1 id=\"设置CentOS参数\"><a href=\"#设置CentOS参数\" class=\"headerlink\" title=\"设置CentOS参数\"></a>设置CentOS参数</h1><ol>\n<li>打开vmware workstations，<code>文件-&gt;新建虚拟机</code>，出现如下界面，选择<code>自定义（高级）</code>选项，下一步继续：<img src=\"/2018/04/16/虚拟机安装CentOS教程/1.jpg\" title=\"[选择操作系统镜像]\">\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"设置虚拟机参数\"><a href=\"#设置虚拟机参数\" class=\"headerlink\" title=\"设置虚拟机参数\"></a>设置虚拟机参数</h1><h2 id=\"小标题1\"><a href=\"#小标题1\" class=\"headerlink\" title=\"小标题1\"></a>小标题1</h2><ol>\n<li><p>打开vmware workstations，<code>文件-&gt;新建虚拟机</code>，出现如下界面，选择<code>自定义（高级）</code>选项，下一步继续：</p>\n<img src=\"/2018/04/16/虚拟机安装CentOS教程/1.jpg\" title=\"[选择操作系统镜像]\">\n</li>\n<li><p>打开vmware workstations，<code>文件-&gt;新建虚拟机</code>，出现如下界面，选择<code>自定义（高级）</code>选项，下一步继续：</p>\n<img src=\"/2018/04/16/虚拟机安装CentOS教程/1.jpg\" title=\"[选择操作系统镜像]\">\n</li>\n</ol>\n<h1 id=\"设置CentOS参数\"><a href=\"#设置CentOS参数\" class=\"headerlink\" title=\"设置CentOS参数\"></a>设置CentOS参数</h1><ol>\n<li>打开vmware workstations，<code>文件-&gt;新建虚拟机</code>，出现如下界面，选择<code>自定义（高级）</code>选项，下一步继续：<img src=\"/2018/04/16/虚拟机安装CentOS教程/1.jpg\" title=\"[选择操作系统镜像]\">\n</li>\n</ol>\n"},{"title":"计数排序","date":"2018-04-16T15:20:40.000Z","_content":"计数排序用到一个额外的计数数组C，根据数组C来将原数组A中的元素排到正确的位置。\n通俗地理解，例如有10个年龄不同的人，假如统计出有8个人的年龄不比小明大（即小于等于小明的年龄，这里也包括了小明），那么小明的年龄就排在第8位，通过这种思想可以确定每个人的位置，也就排好了序。当然，年龄一样时需要特殊处理（保证稳定性）：通过反向填充目标数组，填充完毕后将对应的数字统计递减，可以确保计数排序的稳定性。\n计数排序的步骤如下：\n        1. 统计数组A中每个值A[i]出现的次数，存入C[A[i]]\n        2. 从前向后，使数组C中的每个值等于其与前一项相加，这样数组C[A[i]]就变成了代表数组A中小于等于A[i]的元素个数\n        3. 反向填充目标数组B：将数组元素A[i]放在数组B的第C[A[i]]个位置（下标为C[A[i]] - 1），每放一个元素就将C[A[i]]递减\n计数排序的实现代码如下：\n\n#include<iostream>\nusing namespace std;\n// 分类 ------------ 内部非比较排序\n// 数据结构 --------- 数组\n// 最差时间复杂度 ---- O(n + k)\n// 最优时间复杂度 ---- O(n + k)\n// 平均时间复杂度 ---- O(n + k)\n// 所需辅助空间 ------ O(n + k)\n// 稳定性 ----------- 稳定\nconst int k = 100;   // 基数为100，排序[0,99]内的整数\nint C[k];            // 计数数组\nvoid CountingSort(int A[], int n)\n{\n    for (int i = 0; i < k; i++)   // 初始化，将数组C中的元素置0(此步骤可省略，整型数组元素默认值为0)\n    {\n        C[i] = 0;\n    }\n    for (int i = 0; i < n; i++)   // 使C[i]保存着等于i的元素个数\n    {\n        C[A[i]]++;\n    }\n    for (int i = 1; i < k; i++)   // 使C[i]保存着小于等于i的元素个数，排序后元素i就放在第C[i]个输出位置上\n    {\n        C[i] = C[i] + C[i - 1];\n    }\n    int *B = (int *)malloc((n) * sizeof(int));// 分配临时空间,长度为n，用来暂存中间数据\n    for (int i = n - 1; i >= 0; i--)    // 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)\n    {\n        B[--C[A[i]]] = A[i];      // 把每个元素A[i]放到它在输出数组B中的正确位置上\n                                  // 当再遇到重复元素时会被放在当前元素的前一个位置上保证计数排序的稳定性\n    }\n    for (int i = 0; i < n; i++)   // 把临时空间B中的数据拷贝回A\n    {\n        A[i] = B[i];\n    }\n    free(B);    // 释放临时空间 \n}\nint main()\n{\n    int A[] = { 15, 22, 19, 46, 27, 73, 1, 19, 8 };  // 针对计数排序设计的输入，每一个元素都在[0,100]上且有重复元素\n    int n = sizeof(A) / sizeof(int);\n    CountingSort(A, n);\n    printf(\"计数排序结果：\");\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \", A[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \n下图给出了对{ 4, 1, 3, 4, 3 }进行计数排序的简单演示过程\n\n计数排序的时间复杂度和空间复杂度与数组A的数据范围（A中元素的最大值与最小值的差加上1）有关，因此对于数据范围很大的数组，计数排序需要大量时间和内存。\n例如：对0到99之间的数字进行排序，计数排序是最好的算法，然而计数排序并不适合按字母顺序排序人名，将计数排序用在基数排序算法中，能够更有效的排序数据范围很大的数组。\n","source":"_posts/计数排序.md","raw":"---\ntitle: 计数排序\ntags: \n- 算法排序\n- 基础知识\ncategories: \n- 基础知识\n- 算法排序\ndate: 2018-04-16 23:20:40\n---\n计数排序用到一个额外的计数数组C，根据数组C来将原数组A中的元素排到正确的位置。\n通俗地理解，例如有10个年龄不同的人，假如统计出有8个人的年龄不比小明大（即小于等于小明的年龄，这里也包括了小明），那么小明的年龄就排在第8位，通过这种思想可以确定每个人的位置，也就排好了序。当然，年龄一样时需要特殊处理（保证稳定性）：通过反向填充目标数组，填充完毕后将对应的数字统计递减，可以确保计数排序的稳定性。\n计数排序的步骤如下：\n        1. 统计数组A中每个值A[i]出现的次数，存入C[A[i]]\n        2. 从前向后，使数组C中的每个值等于其与前一项相加，这样数组C[A[i]]就变成了代表数组A中小于等于A[i]的元素个数\n        3. 反向填充目标数组B：将数组元素A[i]放在数组B的第C[A[i]]个位置（下标为C[A[i]] - 1），每放一个元素就将C[A[i]]递减\n计数排序的实现代码如下：\n\n#include<iostream>\nusing namespace std;\n// 分类 ------------ 内部非比较排序\n// 数据结构 --------- 数组\n// 最差时间复杂度 ---- O(n + k)\n// 最优时间复杂度 ---- O(n + k)\n// 平均时间复杂度 ---- O(n + k)\n// 所需辅助空间 ------ O(n + k)\n// 稳定性 ----------- 稳定\nconst int k = 100;   // 基数为100，排序[0,99]内的整数\nint C[k];            // 计数数组\nvoid CountingSort(int A[], int n)\n{\n    for (int i = 0; i < k; i++)   // 初始化，将数组C中的元素置0(此步骤可省略，整型数组元素默认值为0)\n    {\n        C[i] = 0;\n    }\n    for (int i = 0; i < n; i++)   // 使C[i]保存着等于i的元素个数\n    {\n        C[A[i]]++;\n    }\n    for (int i = 1; i < k; i++)   // 使C[i]保存着小于等于i的元素个数，排序后元素i就放在第C[i]个输出位置上\n    {\n        C[i] = C[i] + C[i - 1];\n    }\n    int *B = (int *)malloc((n) * sizeof(int));// 分配临时空间,长度为n，用来暂存中间数据\n    for (int i = n - 1; i >= 0; i--)    // 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)\n    {\n        B[--C[A[i]]] = A[i];      // 把每个元素A[i]放到它在输出数组B中的正确位置上\n                                  // 当再遇到重复元素时会被放在当前元素的前一个位置上保证计数排序的稳定性\n    }\n    for (int i = 0; i < n; i++)   // 把临时空间B中的数据拷贝回A\n    {\n        A[i] = B[i];\n    }\n    free(B);    // 释放临时空间 \n}\nint main()\n{\n    int A[] = { 15, 22, 19, 46, 27, 73, 1, 19, 8 };  // 针对计数排序设计的输入，每一个元素都在[0,100]上且有重复元素\n    int n = sizeof(A) / sizeof(int);\n    CountingSort(A, n);\n    printf(\"计数排序结果：\");\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \", A[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \n下图给出了对{ 4, 1, 3, 4, 3 }进行计数排序的简单演示过程\n\n计数排序的时间复杂度和空间复杂度与数组A的数据范围（A中元素的最大值与最小值的差加上1）有关，因此对于数据范围很大的数组，计数排序需要大量时间和内存。\n例如：对0到99之间的数字进行排序，计数排序是最好的算法，然而计数排序并不适合按字母顺序排序人名，将计数排序用在基数排序算法中，能够更有效的排序数据范围很大的数组。\n","slug":"计数排序","published":1,"updated":"2018-04-29T06:42:47.109Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgkim80h000viku7730mjct2","content":"<p>计数排序用到一个额外的计数数组C，根据数组C来将原数组A中的元素排到正确的位置。<br>通俗地理解，例如有10个年龄不同的人，假如统计出有8个人的年龄不比小明大（即小于等于小明的年龄，这里也包括了小明），那么小明的年龄就排在第8位，通过这种思想可以确定每个人的位置，也就排好了序。当然，年龄一样时需要特殊处理（保证稳定性）：通过反向填充目标数组，填充完毕后将对应的数字统计递减，可以确保计数排序的稳定性。<br>计数排序的步骤如下：</p>\n<pre><code>1. 统计数组A中每个值A[i]出现的次数，存入C[A[i]]\n2. 从前向后，使数组C中的每个值等于其与前一项相加，这样数组C[A[i]]就变成了代表数组A中小于等于A[i]的元素个数\n3. 反向填充目标数组B：将数组元素A[i]放在数组B的第C[A[i]]个位置（下标为C[A[i]] - 1），每放一个元素就将C[A[i]]递减\n</code></pre><p>计数排序的实现代码如下：</p>\n<p>#include<iostream><br>using namespace std;<br>// 分类 ———— 内部非比较排序<br>// 数据结构 ——— 数组<br>// 最差时间复杂度 —- O(n + k)<br>// 最优时间复杂度 —- O(n + k)<br>// 平均时间复杂度 —- O(n + k)<br>// 所需辅助空间 —— O(n + k)<br>// 稳定性 ———– 稳定<br>const int k = 100;   // 基数为100，排序[0,99]内的整数<br>int C[k];            // 计数数组<br>void CountingSort(int A[], int n)<br>{<br>    for (int i = 0; i &lt; k; i++)   // 初始化，将数组C中的元素置0(此步骤可省略，整型数组元素默认值为0)<br>    {<br>        C[i] = 0;<br>    }<br>    for (int i = 0; i &lt; n; i++)   // 使C[i]保存着等于i的元素个数<br>    {<br>        C[A[i]]++;<br>    }<br>    for (int i = 1; i &lt; k; i++)   // 使C[i]保存着小于等于i的元素个数，排序后元素i就放在第C[i]个输出位置上<br>    {<br>        C[i] = C[i] + C[i - 1];<br>    }<br>    int <em>B = (int </em>)malloc((n) * sizeof(int));// 分配临时空间,长度为n，用来暂存中间数据<br>    for (int i = n - 1; i &gt;= 0; i–)    // 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)<br>    {<br>        B[–C[A[i]]] = A[i];      // 把每个元素A[i]放到它在输出数组B中的正确位置上<br>                                  // 当再遇到重复元素时会被放在当前元素的前一个位置上保证计数排序的稳定性<br>    }<br>    for (int i = 0; i &lt; n; i++)   // 把临时空间B中的数据拷贝回A<br>    {<br>        A[i] = B[i];<br>    }<br>    free(B);    // 释放临时空间<br>}<br>int main()<br>{<br>    int A[] = { 15, 22, 19, 46, 27, 73, 1, 19, 8 };  // 针对计数排序设计的输入，每一个元素都在[0,100]上且有重复元素<br>    int n = sizeof(A) / sizeof(int);<br>    CountingSort(A, n);<br>    printf(“计数排序结果：”);<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        printf(“%d “, A[i]);<br>    }<br>    printf(“\\n”);<br>    return 0;<br>}</iostream></p>\n<p>下图给出了对{ 4, 1, 3, 4, 3 }进行计数排序的简单演示过程</p>\n<p>计数排序的时间复杂度和空间复杂度与数组A的数据范围（A中元素的最大值与最小值的差加上1）有关，因此对于数据范围很大的数组，计数排序需要大量时间和内存。<br>例如：对0到99之间的数字进行排序，计数排序是最好的算法，然而计数排序并不适合按字母顺序排序人名，将计数排序用在基数排序算法中，能够更有效的排序数据范围很大的数组。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>计数排序用到一个额外的计数数组C，根据数组C来将原数组A中的元素排到正确的位置。<br>通俗地理解，例如有10个年龄不同的人，假如统计出有8个人的年龄不比小明大（即小于等于小明的年龄，这里也包括了小明），那么小明的年龄就排在第8位，通过这种思想可以确定每个人的位置，也就排好了序。当然，年龄一样时需要特殊处理（保证稳定性）：通过反向填充目标数组，填充完毕后将对应的数字统计递减，可以确保计数排序的稳定性。<br>计数排序的步骤如下：</p>\n<pre><code>1. 统计数组A中每个值A[i]出现的次数，存入C[A[i]]\n2. 从前向后，使数组C中的每个值等于其与前一项相加，这样数组C[A[i]]就变成了代表数组A中小于等于A[i]的元素个数\n3. 反向填充目标数组B：将数组元素A[i]放在数组B的第C[A[i]]个位置（下标为C[A[i]] - 1），每放一个元素就将C[A[i]]递减\n</code></pre><p>计数排序的实现代码如下：</p>\n<p>#include<iostream><br>using namespace std;<br>// 分类 ———— 内部非比较排序<br>// 数据结构 ——— 数组<br>// 最差时间复杂度 —- O(n + k)<br>// 最优时间复杂度 —- O(n + k)<br>// 平均时间复杂度 —- O(n + k)<br>// 所需辅助空间 —— O(n + k)<br>// 稳定性 ———– 稳定<br>const int k = 100;   // 基数为100，排序[0,99]内的整数<br>int C[k];            // 计数数组<br>void CountingSort(int A[], int n)<br>{<br>    for (int i = 0; i &lt; k; i++)   // 初始化，将数组C中的元素置0(此步骤可省略，整型数组元素默认值为0)<br>    {<br>        C[i] = 0;<br>    }<br>    for (int i = 0; i &lt; n; i++)   // 使C[i]保存着等于i的元素个数<br>    {<br>        C[A[i]]++;<br>    }<br>    for (int i = 1; i &lt; k; i++)   // 使C[i]保存着小于等于i的元素个数，排序后元素i就放在第C[i]个输出位置上<br>    {<br>        C[i] = C[i] + C[i - 1];<br>    }<br>    int <em>B = (int </em>)malloc((n) * sizeof(int));// 分配临时空间,长度为n，用来暂存中间数据<br>    for (int i = n - 1; i &gt;= 0; i–)    // 从后向前扫描保证计数排序的稳定性(重复元素相对次序不变)<br>    {<br>        B[–C[A[i]]] = A[i];      // 把每个元素A[i]放到它在输出数组B中的正确位置上<br>                                  // 当再遇到重复元素时会被放在当前元素的前一个位置上保证计数排序的稳定性<br>    }<br>    for (int i = 0; i &lt; n; i++)   // 把临时空间B中的数据拷贝回A<br>    {<br>        A[i] = B[i];<br>    }<br>    free(B);    // 释放临时空间<br>}<br>int main()<br>{<br>    int A[] = { 15, 22, 19, 46, 27, 73, 1, 19, 8 };  // 针对计数排序设计的输入，每一个元素都在[0,100]上且有重复元素<br>    int n = sizeof(A) / sizeof(int);<br>    CountingSort(A, n);<br>    printf(“计数排序结果：”);<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        printf(“%d “, A[i]);<br>    }<br>    printf(“\\n”);<br>    return 0;<br>}</iostream></p>\n<p>下图给出了对{ 4, 1, 3, 4, 3 }进行计数排序的简单演示过程</p>\n<p>计数排序的时间复杂度和空间复杂度与数组A的数据范围（A中元素的最大值与最小值的差加上1）有关，因此对于数据范围很大的数组，计数排序需要大量时间和内存。<br>例如：对0到99之间的数字进行排序，计数排序是最好的算法，然而计数排序并不适合按字母顺序排序人名，将计数排序用在基数排序算法中，能够更有效的排序数据范围很大的数组。</p>\n"},{"title":"选择排序","date":"2018-04-16T15:20:40.000Z","_content":"\n选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。\n选择排序的代码如下：\n\n#include <stdio.h>\n// 分类 -------------- 内部比较排序\n// 数据结构 ---------- 数组\n// 最差时间复杂度 ---- O(n^2)\n// 最优时间复杂度 ---- O(n^2)\n// 平均时间复杂度 ---- O(n^2)\n// 所需辅助空间 ------ O(1)\n// 稳定性 ------------ 不稳定\nvoid Swap(int A[], int i, int j)\n{\n    int temp = A[i];\n    A[i] = A[j];\n    A[j] = temp;\n}\nvoid SelectionSort(int A[], int n)\n{\n    for (int i = 0; i < n - 1; i++)         // i为已排序序列的末尾\n    {\n        int min = i;\n        for (int j = i + 1; j < n; j++)     // 未排序序列\n        {\n            if (A[j] < A[min])              // 找出未排序序列中的最小值\n            {\n                min = j;\n            }\n        }\n        if (min != i)\n        {\n            Swap(A, min, i);    // 放到已排序序列的末尾，该操作很有可能把稳定性打乱，所以选择排序是不稳定的排序算法\n        }\n    }\n}\nint main()\n{\n    int A[] = { 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 }; // 从小到大选择排序\n    int n = sizeof(A) / sizeof(int);\n    SelectionSort(A, n);\n    printf(\"选择排序结果：\");\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \", A[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \n 　　上述代码对序列{ 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 }进行选择排序的实现过程如右图\n\n \n使用选择排序为一列数字进行排序的宏观过程：\n\n选择排序是不稳定的排序算法，不稳定发生在最小元素与A[i]交换的时刻。\n比如序列：{ 5, 8, 5, 2, 9 }，一次选择的最小元素是2，然后把2和第一个5进行交换，从而改变了两个元素5的相对次序。\n","source":"_posts/选择排序.md","raw":"---\ntitle: 选择排序\ntags: \n- 算法排序\n- 基础知识\ncategories: \n- 基础知识\n- 算法排序\ndate: 2018-04-16 23:20:40\n---\n\n选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。\n注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。\n选择排序的代码如下：\n\n#include <stdio.h>\n// 分类 -------------- 内部比较排序\n// 数据结构 ---------- 数组\n// 最差时间复杂度 ---- O(n^2)\n// 最优时间复杂度 ---- O(n^2)\n// 平均时间复杂度 ---- O(n^2)\n// 所需辅助空间 ------ O(1)\n// 稳定性 ------------ 不稳定\nvoid Swap(int A[], int i, int j)\n{\n    int temp = A[i];\n    A[i] = A[j];\n    A[j] = temp;\n}\nvoid SelectionSort(int A[], int n)\n{\n    for (int i = 0; i < n - 1; i++)         // i为已排序序列的末尾\n    {\n        int min = i;\n        for (int j = i + 1; j < n; j++)     // 未排序序列\n        {\n            if (A[j] < A[min])              // 找出未排序序列中的最小值\n            {\n                min = j;\n            }\n        }\n        if (min != i)\n        {\n            Swap(A, min, i);    // 放到已排序序列的末尾，该操作很有可能把稳定性打乱，所以选择排序是不稳定的排序算法\n        }\n    }\n}\nint main()\n{\n    int A[] = { 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 }; // 从小到大选择排序\n    int n = sizeof(A) / sizeof(int);\n    SelectionSort(A, n);\n    printf(\"选择排序结果：\");\n    for (int i = 0; i < n; i++)\n    {\n        printf(\"%d \", A[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\n \n 　　上述代码对序列{ 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 }进行选择排序的实现过程如右图\n\n \n使用选择排序为一列数字进行排序的宏观过程：\n\n选择排序是不稳定的排序算法，不稳定发生在最小元素与A[i]交换的时刻。\n比如序列：{ 5, 8, 5, 2, 9 }，一次选择的最小元素是2，然后把2和第一个5进行交换，从而改变了两个元素5的相对次序。\n","slug":"选择排序","published":1,"updated":"2018-04-29T06:42:47.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgkim82s002piku7mpp2dag9","content":"<p>选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。<br>注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。<br>选择排序的代码如下：</p>\n<p>#include &lt;stdio.h&gt;<br>// 分类 ————– 内部比较排序<br>// 数据结构 ———- 数组<br>// 最差时间复杂度 —- O(n^2)<br>// 最优时间复杂度 —- O(n^2)<br>// 平均时间复杂度 —- O(n^2)<br>// 所需辅助空间 —— O(1)<br>// 稳定性 ———— 不稳定<br>void Swap(int A[], int i, int j)<br>{<br>    int temp = A[i];<br>    A[i] = A[j];<br>    A[j] = temp;<br>}<br>void SelectionSort(int A[], int n)<br>{<br>    for (int i = 0; i &lt; n - 1; i++)         // i为已排序序列的末尾<br>    {<br>        int min = i;<br>        for (int j = i + 1; j &lt; n; j++)     // 未排序序列<br>        {<br>            if (A[j] &lt; A[min])              // 找出未排序序列中的最小值<br>            {<br>                min = j;<br>            }<br>        }<br>        if (min != i)<br>        {<br>            Swap(A, min, i);    // 放到已排序序列的末尾，该操作很有可能把稳定性打乱，所以选择排序是不稳定的排序算法<br>        }<br>    }<br>}<br>int main()<br>{<br>    int A[] = { 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 }; // 从小到大选择排序<br>    int n = sizeof(A) / sizeof(int);<br>    SelectionSort(A, n);<br>    printf(“选择排序结果：”);<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        printf(“%d “, A[i]);<br>    }<br>    printf(“\\n”);<br>    return 0;<br>}</p>\n<p> 　　上述代码对序列{ 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 }进行选择排序的实现过程如右图</p>\n<p>使用选择排序为一列数字进行排序的宏观过程：</p>\n<p>选择排序是不稳定的排序算法，不稳定发生在最小元素与A[i]交换的时刻。<br>比如序列：{ 5, 8, 5, 2, 9 }，一次选择的最小元素是2，然后把2和第一个5进行交换，从而改变了两个元素5的相对次序。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。<br>注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。<br>选择排序的代码如下：</p>\n<p>#include &lt;stdio.h&gt;<br>// 分类 ————– 内部比较排序<br>// 数据结构 ———- 数组<br>// 最差时间复杂度 —- O(n^2)<br>// 最优时间复杂度 —- O(n^2)<br>// 平均时间复杂度 —- O(n^2)<br>// 所需辅助空间 —— O(1)<br>// 稳定性 ———— 不稳定<br>void Swap(int A[], int i, int j)<br>{<br>    int temp = A[i];<br>    A[i] = A[j];<br>    A[j] = temp;<br>}<br>void SelectionSort(int A[], int n)<br>{<br>    for (int i = 0; i &lt; n - 1; i++)         // i为已排序序列的末尾<br>    {<br>        int min = i;<br>        for (int j = i + 1; j &lt; n; j++)     // 未排序序列<br>        {<br>            if (A[j] &lt; A[min])              // 找出未排序序列中的最小值<br>            {<br>                min = j;<br>            }<br>        }<br>        if (min != i)<br>        {<br>            Swap(A, min, i);    // 放到已排序序列的末尾，该操作很有可能把稳定性打乱，所以选择排序是不稳定的排序算法<br>        }<br>    }<br>}<br>int main()<br>{<br>    int A[] = { 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 }; // 从小到大选择排序<br>    int n = sizeof(A) / sizeof(int);<br>    SelectionSort(A, n);<br>    printf(“选择排序结果：”);<br>    for (int i = 0; i &lt; n; i++)<br>    {<br>        printf(“%d “, A[i]);<br>    }<br>    printf(“\\n”);<br>    return 0;<br>}</p>\n<p> 　　上述代码对序列{ 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 }进行选择排序的实现过程如右图</p>\n<p>使用选择排序为一列数字进行排序的宏观过程：</p>\n<p>选择排序是不稳定的排序算法，不稳定发生在最小元素与A[i]交换的时刻。<br>比如序列：{ 5, 8, 5, 2, 9 }，一次选择的最小元素是2，然后把2和第一个5进行交换，从而改变了两个元素5的相对次序。</p>\n"}],"PostAsset":[{"_id":"source/_posts/Markdown语法入门/biaoti1.jpg","slug":"biaoti1.jpg","post":"cjgkim7yb0000iku7e7qeoyvr","modified":0,"renderable":0},{"_id":"source/_posts/虚拟机安装CentOS教程/1.jpg","slug":"1.jpg","post":"cjgkim80d000riku76irl46rz","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjgkim7yb0000iku7e7qeoyvr","category_id":"cjgkim7yp0002iku7sfafjn08","_id":"cjgkim803000liku70en2yjvt"},{"post_id":"cjgkim7yb0000iku7e7qeoyvr","category_id":"cjgkim7zk000biku7jwmriyja","_id":"cjgkim80b000qiku7ab9pwg8h"},{"post_id":"cjgkim808000oiku7qaxc56ao","category_id":"cjgkim7yp0002iku7sfafjn08","_id":"cjgkim80l000yiku7opy3e5fj"},{"post_id":"cjgkim808000oiku7qaxc56ao","category_id":"cjgkim7zk000biku7jwmriyja","_id":"cjgkim80q0012iku7wt7py5cj"},{"post_id":"cjgkim80d000riku76irl46rz","category_id":"cjgkim7yp0002iku7sfafjn08","_id":"cjgkim80r0014iku73jn0lqc0"},{"post_id":"cjgkim80d000riku76irl46rz","category_id":"cjgkim7zk000biku7jwmriyja","_id":"cjgkim80v0018iku7wvwccr1n"},{"post_id":"cjgkim7yv0004iku7g8sf4vtc","category_id":"cjgkim7yp0002iku7sfafjn08","_id":"cjgkim80w001aiku7qonfa5de"},{"post_id":"cjgkim7yv0004iku7g8sf4vtc","category_id":"cjgkim7zk000biku7jwmriyja","_id":"cjgkim810001eiku7xvxntxuu"},{"post_id":"cjgkim7zw000jiku77ui53r76","category_id":"cjgkim7zu000hiku75ce2dqmu","_id":"cjgkim81m001piku7djvlsctt"},{"post_id":"cjgkim7zw000jiku77ui53r76","category_id":"cjgkim812001giku7gelmx6gq","_id":"cjgkim81o001riku7gcmjitr5"},{"post_id":"cjgkim7z30006iku75osu9iv6","category_id":"cjgkim7zu000hiku75ce2dqmu","_id":"cjgkim81q001tiku7gb961lts"},{"post_id":"cjgkim7z30006iku75osu9iv6","category_id":"cjgkim812001giku7gelmx6gq","_id":"cjgkim81s001wiku7k0s5my70"},{"post_id":"cjgkim801000kiku7x69ugjlb","category_id":"cjgkim7zu000hiku75ce2dqmu","_id":"cjgkim81v001ziku7bc2loz8k"},{"post_id":"cjgkim801000kiku7x69ugjlb","category_id":"cjgkim812001giku7gelmx6gq","_id":"cjgkim81x0021iku7bppq2vl0"},{"post_id":"cjgkim7zg0009iku7tzxmhv3s","category_id":"cjgkim7zu000hiku75ce2dqmu","_id":"cjgkim81y0023iku73k664sjf"},{"post_id":"cjgkim7zg0009iku7tzxmhv3s","category_id":"cjgkim812001giku7gelmx6gq","_id":"cjgkim8220026iku76sz6ztbm"},{"post_id":"cjgkim80h000viku7730mjct2","category_id":"cjgkim7zu000hiku75ce2dqmu","_id":"cjgkim8240029iku7uxzbuviz"},{"post_id":"cjgkim80h000viku7730mjct2","category_id":"cjgkim812001giku7gelmx6gq","_id":"cjgkim826002biku7y71patdx"},{"post_id":"cjgkim7zi000aiku71ebel28c","category_id":"cjgkim7zu000hiku75ce2dqmu","_id":"cjgkim828002diku7akhmf9sv"},{"post_id":"cjgkim7zi000aiku71ebel28c","category_id":"cjgkim812001giku7gelmx6gq","_id":"cjgkim82d002giku7eojtbmd5"},{"post_id":"cjgkim7zm000diku7kne4ciut","category_id":"cjgkim7zu000hiku75ce2dqmu","_id":"cjgkim82e002iiku7u51w62zq"},{"post_id":"cjgkim7zm000diku7kne4ciut","category_id":"cjgkim812001giku7gelmx6gq","_id":"cjgkim82g002kiku73uljr536"},{"post_id":"cjgkim7zp000fiku7gngd8y65","category_id":"cjgkim7zu000hiku75ce2dqmu","_id":"cjgkim82g002liku7npaf2w0o"},{"post_id":"cjgkim7zp000fiku7gngd8y65","category_id":"cjgkim812001giku7gelmx6gq","_id":"cjgkim82i002niku7l6ezilg9"},{"post_id":"cjgkim82s002piku7mpp2dag9","category_id":"cjgkim7zu000hiku75ce2dqmu","_id":"cjgkim82w002siku7hnt32xmj"},{"post_id":"cjgkim82s002piku7mpp2dag9","category_id":"cjgkim812001giku7gelmx6gq","_id":"cjgkim82x002tiku7641qosn6"}],"PostTag":[{"post_id":"cjgkim7yb0000iku7e7qeoyvr","tag_id":"cjgkim7ys0003iku72swbjc51","_id":"cjgkim7zo000eiku7o9bq92c3"},{"post_id":"cjgkim7yb0000iku7e7qeoyvr","tag_id":"cjgkim7z60008iku76rtn9t32","_id":"cjgkim7zt000giku77pdv2cm5"},{"post_id":"cjgkim7yv0004iku7g8sf4vtc","tag_id":"cjgkim7ys0003iku72swbjc51","_id":"cjgkim80a000piku7nwhb0jx3"},{"post_id":"cjgkim7yv0004iku7g8sf4vtc","tag_id":"cjgkim7z60008iku76rtn9t32","_id":"cjgkim80e000siku7c19w0ezg"},{"post_id":"cjgkim808000oiku7qaxc56ao","tag_id":"cjgkim7ys0003iku72swbjc51","_id":"cjgkim80i000wiku7ojtmllih"},{"post_id":"cjgkim808000oiku7qaxc56ao","tag_id":"cjgkim7z60008iku76rtn9t32","_id":"cjgkim80k000xiku79qhha59n"},{"post_id":"cjgkim80d000riku76irl46rz","tag_id":"cjgkim7ys0003iku72swbjc51","_id":"cjgkim80p0011iku7whs2zz29"},{"post_id":"cjgkim80d000riku76irl46rz","tag_id":"cjgkim7z60008iku76rtn9t32","_id":"cjgkim80r0013iku78b749etj"},{"post_id":"cjgkim80h000viku7730mjct2","tag_id":"cjgkim804000miku7m65w0p00","_id":"cjgkim80u0017iku7ho3w5p7m"},{"post_id":"cjgkim80h000viku7730mjct2","tag_id":"cjgkim80g000uiku7bb8l63eh","_id":"cjgkim80v0019iku7n9nwwelf"},{"post_id":"cjgkim7z30006iku75osu9iv6","tag_id":"cjgkim804000miku7m65w0p00","_id":"cjgkim80z001diku75yvrw9sm"},{"post_id":"cjgkim7z30006iku75osu9iv6","tag_id":"cjgkim80g000uiku7bb8l63eh","_id":"cjgkim811001fiku7l12kv04d"},{"post_id":"cjgkim7zg0009iku7tzxmhv3s","tag_id":"cjgkim804000miku7m65w0p00","_id":"cjgkim815001iiku72n3cu9te"},{"post_id":"cjgkim7zg0009iku7tzxmhv3s","tag_id":"cjgkim80g000uiku7bb8l63eh","_id":"cjgkim817001jiku72w3wmvs6"},{"post_id":"cjgkim7zi000aiku71ebel28c","tag_id":"cjgkim804000miku7m65w0p00","_id":"cjgkim81d001miku798w7hk69"},{"post_id":"cjgkim7zi000aiku71ebel28c","tag_id":"cjgkim80g000uiku7bb8l63eh","_id":"cjgkim81i001niku776tuzb14"},{"post_id":"cjgkim7zm000diku7kne4ciut","tag_id":"cjgkim804000miku7m65w0p00","_id":"cjgkim81s001viku7m3en0dog"},{"post_id":"cjgkim7zm000diku7kne4ciut","tag_id":"cjgkim80g000uiku7bb8l63eh","_id":"cjgkim81t001xiku7z9b0yxg7"},{"post_id":"cjgkim7zp000fiku7gngd8y65","tag_id":"cjgkim804000miku7m65w0p00","_id":"cjgkim8210025iku7501juwni"},{"post_id":"cjgkim7zp000fiku7gngd8y65","tag_id":"cjgkim80g000uiku7bb8l63eh","_id":"cjgkim8230027iku7ks6gijra"},{"post_id":"cjgkim7zw000jiku77ui53r76","tag_id":"cjgkim804000miku7m65w0p00","_id":"cjgkim82c002fiku7vbaw625r"},{"post_id":"cjgkim7zw000jiku77ui53r76","tag_id":"cjgkim80g000uiku7bb8l63eh","_id":"cjgkim82e002hiku7qemlcdgv"},{"post_id":"cjgkim801000kiku7x69ugjlb","tag_id":"cjgkim804000miku7m65w0p00","_id":"cjgkim82h002miku7h26urhpf"},{"post_id":"cjgkim801000kiku7x69ugjlb","tag_id":"cjgkim80g000uiku7bb8l63eh","_id":"cjgkim82j002oiku7oei3mtcz"},{"post_id":"cjgkim82s002piku7mpp2dag9","tag_id":"cjgkim804000miku7m65w0p00","_id":"cjgkim82v002qiku71ybnckdp"},{"post_id":"cjgkim82s002piku7mpp2dag9","tag_id":"cjgkim80g000uiku7bb8l63eh","_id":"cjgkim82w002riku7sj3pj58h"}],"Tag":[{"name":"工具安装","_id":"cjgkim7ys0003iku72swbjc51"},{"name":"操作系统","_id":"cjgkim7z60008iku76rtn9t32"},{"name":"算法排序","_id":"cjgkim804000miku7m65w0p00"},{"name":"基础知识","_id":"cjgkim80g000uiku7bb8l63eh"}]}}